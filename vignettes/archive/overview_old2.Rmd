---
title: "overview"
output: rmarkdown::html_vignette
        #pdf_document
vignette: >
  %\VignetteIndexEntry{overview}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## tidy data in population genetics

The fundamental tenet of tidy data that is that each observation should have its
own row and each variable its own column, such that each value has its own cell.
Applying this logic to population genetic data means that each individual should
have its own row, with individual metadata (such as its population, sex, phenotype, etc)
as the variables. Genotypes for each locus can also be thought as variables, however, due
to the large number of loci and the restricted values that each genotype can take, it would
be very inefficient to store them as individual standard columns. 

In `tidypopgen`, we represent data as a `gen_tbl`, a subclass of `tibble` which has
four compulsory columns: `id` of the individual (as a `character`, which must 
be unique for each individual), `population` giving the population the 
individuals belong to (a `factor`), and `genotypes` (stored in a compressed format
as a list, one
object per individual representing its genotypes for all loci). 
In order to define the loci stored in the compressed objects in the `genotype` list,
we also require an additional tibble stored as the attribute `loci` to the column `genotypes`. 
The `loci` tibble includes columns
`name` for the locus name (a `character`, which must be unique), `chromosome` for the chromosome (`a factor`, if known, 
otherwise set to `NA`), `position` for the position on the chromosome (`numeric`, if known, 
otherwise set to `NA`), `allele_ref` for the the reference allele (a character),
and `allele_alt` for the alternate allele (a character, which can be `NA` for
monomorphic loci). Additional individual metadata can be stored as columns in
the main `gen_tbl`, whilst additional loci information (such as the position in 
centimorgans) can be added as columns in the `loci` attribute table.

In principle, it is possible to use use multiple ways to compress the genotypes.
`tidypopgen` currently uses `SNPBin` from the package `adegenet`. It is very
memory efficient, and it is flexible in representing multiple ploidy. But the
infrastructure is present to adopt alternative compression approaches in the future
the only constraint is that the data have to be representable as a list of n elements
where n is the number of individuals (i.e. one object per individual).

## The grammar of population genetics

### The `gen_tibble`

Given information about the individuals, their genotypes, and the loci:
```{r}
library(tidypopgen)
example_ind_meta <- data.frame (id=c("a","b","c","d","e"),
                       population = c("pop1","pop1","pop2","pop2","pop2"))
example_genotypes <- rbind(c(1, 1, 0, 1, 1, 0), 
                        c(2, 0, 0, 0,NA, 0), 
                        c(1, 2, 0, 0, 1, 1),
                        c(0, 2, 0, 1, 2, 1),
                        c(1, 1,NA, 2, 1, 0))
example_loci <- data.frame(name=c("rs1","rs2","rs3","rs4","x1","x2"),
                   chromosome=c(1,1,1,1,2,2),
                   position=c(3,5,65,343,23,456),
                   allele_ref = c("a","t","c","g","c","t"),
                   allele_alt = c("t","c", NA,"c","g","a"))
```

We create a plink BED file:
```{r}
bed_prefix <- tempfile('test_data_')
make_test_bed(example_genotypes, example_loci, example_ind_meta, bed_prefix)
bed_path <- paste0(bed_prefix,".bed")

```

We convert the BED file into a bigSNP file format (this will generate a backing file and an RDS file,
with prefix "test_bigfile_":
```{r}
bigsnp_path <- bigsnpr::snp_readBed(bed_path, backingfile = tempfile("test_bigfile_"))
```

We can create a simple `gen_tibble` object (of class `gen_tbl`) with
```{r}
example_gt <- gen_tibble(bigsnp_path)
example_gt
```
As discussed above, in this tibble, genotypes are stored as a list of 
compressed `SNPbin` objects.


Note that, if we are passing a `gen_tibble` to a function that works on
genotypes, it is not necessary to pass the column `genotypes` in the call.
However, if such a function is used within a `dplyr` verb such as `mutate`,
we need to pass the `genotype` column to the function:

```{r}
example_gt %>% mutate (het_obs = ind_het_obs(.data$genotypes))
```
Or, more simply:
```{r}
example_gt %>% mutate (het_obs = ind_het_obs(genotypes))
```

To retrieve the genotypes (which are compressed), we use:
```{r}
example_gt %>% show_genotypes()
```

If we want to extract the information about the loci for which we have genotypes
(which are stored as an attribute of that column),
we say:
```{r}
example_gt %>% show_loci()
```

## Standard `dplyr` verbs to manipulate the tibble

The individual metadata can then be processed with the usual `tidiverse` grammar.
So, we can filter individuals by population with
```{r}
example_pop1 <- example_gt %>% filter (population=="pop2")
example_pop1
```

There are a number of functions that compute population genetics quantities for each
individual, such as individual observed heterozygosity. We can compute them simply with:
```{r}
example_gt %>% ind_het_obs()
```

Or after filtering:
```{r}
example_gt %>% filter (population=="pop2") %>% ind_het_obs()

```

We can use `mutate` to add observed heterozygosity as a column to our
`gen_tibble` (again, note that functions that work on genotypes don't need
to be passed any arguments if the tibble is passed directly to them, but
the column `genotypes` has to be provided when they are used within
`dplyr` verbs such as `mutate`):
```{r}
example_gt %>% mutate(het_obs = ind_het_obs(genotypes))
```

# Using verbs on loci

Since the genotypes of the loci are stored as a compressed list in one column,
it is not possible to use standard `dplyr` verbs on them. However, `tidypopgen` provides
a number of specialised verbs, postfixed by `_loci`, to manipulate loci. 

A key operation on loci is their selection (and removal). The compressed nature
of genotypes imposes some constraints on the possible grammar.
For selection, there are two verbs: `select_loci` and `select_loci_if`. 
`select_loci` understands the concise-minilanguage spoken by standard `dplyr::select`
that allows to easily refer to variables by their names. However, `select_loci`
criteria can not be based on the actual genotypes (e.g. on heterozygosity or 
missingness). For that, we have to use `select_loci_if`, which can operate on the
genotypes but is blind to the names of loci.

Let us start by looking at the loci names in our simple dataset:
```{r}
show_loci_names(example_gt)

```

We can see that there are two categories of loci, one starting with "rs" and
the other with "x". If we wanted to select only loci that have an "rs" code,
we would use:
```{r}
example_sub <- example_gt %>% select_loci (starts_with("rs"))
example_sub
```
This gives us a `gen_tibble` with only 4 loci, as expected. We can confirm that
we have the correct loci with:
```{r}
show_loci_names(example_sub)
```

Let us check that this has indeed impacted the individual heterozygosity
```{r}
example_sub %>% ind_het_obs()
```

We can also subset and reorder by passing indeces (note that we extract the loci
information, but in reality we have reordered and subsetted the genotypes
for all individuals):
```{r}
example_gt %>% select_loci (c(2,6,1)) %>% show_loci()
```
This operation could be helpful when merging datasets that do not fully
overlap on their loci (more on that later).

```{r}
example_gt %>% select_loci (c(2,6,1)) %>% show_genotypes()
```


The limit of `select_loci` is that it can not directly summarise the genotypes.
We can do that separately and then feed the result as a set of indeces. For 
example, we might want to impose a minimum minor allele frequency. 
`loci_freq()` allows us to inspect the frequencies in a `gen_tibble`: 
```{r}
example_gt %>% loci_freq()
```

We can now create a vector of indices of loci with a minimum allele frequency
(MAF) larger than 0.2, and use it to select:

```{r}
sel_indices <- which((example_gt %>% loci_freq())>0.2)
example_gt %>% select_loci (all_of(sel_indices)) %>% show_loci()
```

Note that passing a variable direclty to `select` is deprecated, and so we have
to use `all_of` to wrap it.

`select_loci_if` allows us to avoid creating a temporary variable to store indices:

```{r}
example_gt_sub <- example_gt %>% select_loci_if(loci_freq(genotypes)>0.2)
example_gt_sub %>% show_genotypes()
```

Note that, as we need to tidy evaluate `loci_freq` within the `select_loci_if` verb,
we need to provide it with the column that we want to use (even though it has
to be `genotypes`). Also note that, with `select_loci_if`, we can not reorder
the loci.

`select_loci_if` is very flexible; for example, we could filter loci with a MAF
greater than 0.2 that are also on chromosome 2

We can use a similar approach to select only alleles on a given chromosome:
```{r}
example_gt %>% select_loci_if(show_loci(genotypes)$chromosome==2 &
                             loci_freq(genotypes)>0.2) %>% show_loci()
```


# Grouping individuals in populations

In population genetics, we are generally interested in computing quantities that
describe groups of individuals (i.e. populations). Grouping can be used in a 
number of ways.

As a starting point, we can group by population and get pop sizes:
```{r}
example_gt %>% group_by(population) %>% tally()
```

For functions that return one result per individual (such as
`ind_H_obs` that we used before), we can use summarise, which returns a
new `tibble` with one line per population. For example, we can count the number of individuals 
per population, as well as their mean heterozygosity with :
```{r}
example_gt %>% group_by(population) %>% 
  summarise(n= n(), mean_het = mean(ind_het_obs(genotypes)))
```



For functions that return a quantity per locus (e.g. `loci_freq`), we can use 
 `group_by` together with `group_map` to apply such functions over populations:
```{r}
example_gt %>% group_by(population) %>% group_map(.f = ~loci_freq(.x))
```

For more details on the syntax of `group_map`, see its help page. Some 
functions, such as `loci_freq()`, also have a method for grouped tibbles that 
allows an even easier syntax:

```{r}
example_gt %>% group_by(population) %>% loci_freq()
```

In reality, such grouped methods are nothing more than a wrapper for the
the appropriate `group_map` syntax, but they do make life a little bit simpler.

Certain metrics and analysis are naturally defined by a grouped tibble, such as
distance metrics among populations. For example:

```{r}
example_gt %>% group_by(population) %>% gt_pairwise_fst()
```

# Reading and exporting data

Currently, `tidypopgen` can read data only from PLINK bed files. Plink has the
ability to convert a large number of formats.

It can export data in the same format. We will save the dataset to
a file in the temporary directory:
```{r}
out_file <- tempfile()
gt_write_plink(plink_gt, file = out_file)
```

This will write both a `.raw` file as well as a `.map` file

Furthermore, it is possible to import vcf files via `vcfR`. If we have a `vcfR`
object, we can simply:
```{r}
library(vcfR)
data(vcfR_test)
vcf_gt <- as_gen_tibble(vcfR_test)
vcf_gt

```

# Merging data

Merging data from different sources is a common problem, especially in human population
genetics where there is a wealth of SNP chips available. In `tidypopgen`, merging is
enacted with an `rbind` operation between `gen_tibbles`. If the datasets have the same
loci, then the merge is trivial. If not, then it is necessary to subset to the same
loci, and ensure that the data are coded with the same reference and alternate 
alleles (or swap if needed). Additionally, if data come from SNP chips, there is
the added complication that the strand is not always consistent, so it might also
be necessary to flip strand (in that case, ambiguous SNPs have to be filtered).
The `rbind` method for `gen_tibbles` has a number of parameters that allow us to
control the behaviour of the merge.

Let us start by bringing in an additional dataset:
```{r}
raw_path2 <- system.file("extdata/pop_b.raw", package = "tidypopgen")
map_path2 <- system.file("extdata/pop_b.map", package = "tidypopgen")
plink_gt2 <- read_plink_raw(file = raw_path2, map_file = map_path2)
plink_gt2
```

Here we are using very small datasets, but in real life, `rbind` operations
are very demanding. Before performing such an operation, we can run
`rbind_dry_run`:
```{r}
report <- rbind_dry_run(plink_gt, plink_gt2, flip_strand = TRUE,
                        remove_ambiguous = TRUE)
```

Note that, by default, `rbind` will NOT flip strand or remove ambiguous SNPs
(as they are only relevant when merging different SNP chips),
you need to set those options to TRUE if you want to use them.

The report object contains details about why each locus was either kept 
or removed, but usually the report is sufficient to make decisions on whether
we want to go ahead. If we are happy with the likely outcome, we can
proceed with the `rbind`:
```{r}
plink_merged <- rbind(plink_gt, plink_gt2, flip_strand = TRUE,
                        remove_ambiguous = TRUE)

```

We can look at the subsetted loci (using the first population as reference to
determine the strand and order of alleles):
```{r}
plink_merged %>% show_loci()
```

# Population genetics analyses

Besides using various metrics to describe populations, we often want to perform
more complex analyses, such as Principal Component Analysis or clustering. 

For example, we can ran a PCA with:

```{r}
pca_merged <- plink_merged %>% gt_pca(nf=2)
pca_merged
```
Objects outputted by different packages and analyese can be difficult to manipulate.
The package `broom` from the tidyverse offers methods 
to easily extract information in form of tibbles ('tidy') and merge some of those outputs with the
original data (`augment`).
`tidypopgen` implements such methods for objects created from its functions. So, 
we can tidy the results as we would do for a standard PCA object from `prcomp`.
So, we can get the eigen values with:
```{r}
tidy(pca_merged, matrix="eigenvalues")
```

And the scores for each individual:
```{r}
tidy(pca_merged)
```

We can also integrate the scores back into our original dataframe with `augment`.
Note that, for objects generated by `tidypopgen`:
```{r}
merged_with_scores<- augment(pca_merged , data= plink_merged)
merged_with_scores
```
Note that, by default, `augment` methods implemented in `tidypopgen` drop the 'genotype'
column, as it greatly reduces the memory footpring of the object. This makes manipulating the data
for plotting less onerous. This behaviour can be changed by setting `drop_genotypes=FALSE`
in `augment`.

We can then easily plot our data with:
```{r}
library(ggplot2)
merged_with_scores %>% ggplot(aes(.fittedPC1, .fittedPC2, color = population)) + 
  geom_point(size = 1.5)
```
We can further customise the plot with the usual `ggplot` functions.

Note that the `merged_pca` object has both class `gt_pca` and `glPca` (the class for PCA
from `genlight` objects from the `adegenet` package):
```{r}
class(pca_merged)
```

This means that we can also use all functions from the `adegenet` package for exploring the PCA. E.g.:
```{r}
scatter(pca_merged)
```

# Obsolete

# This will have to be reconsidered, as swapping alleles on a file based system is VERY intensive
# we can implement it as part of the merging, but not as something to do on the fly
Sometimes it is also of interest to use a particular type of allele (the minor or
the major) when representing gentoypes, either for specific analysis 
or for exporting data. The representation 
we have used so far is arbitrary, but we can use an additional feature of 
`select_loci` and `select_loci_if` to swap the reference and alternate allele.
Both functions include a `.swap_arg` and a `.swap_if_arg`. We case use either
of those parameters to perform select-like operations that define which loci are
swapped. `.swap_arg` is equivalent to `select_loci` in using the `select` mini-grammar
on loci name (but it is blidn to genotype content), whilst `.swap_if_arg` works 
like `select_loci_if` (having access to the genotyes but not the names).




