---
title: "example workflow with tidypopgen"
output: #rmarkdown::html_vignette
        pdf_document
vignette: >
  %\VignetteIndexEntry{example_workflow}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```


## An example workflow with real data
We will explore the genetic structure of *Anolis punctatus* in South America,
using data from Prates et al 2018. We downloaded the vcf file of the genotypes
from "https://github.com/ivanprates/2018_Anolis_EcolEvol/blob/master/data/VCFtools_SNMF_punctatus_t70_s10_n46/punctatus_t70_s10_n46_filtered.recode.vcf?raw=true" and compressed it to a vcf.gz file.

We read in the data from the compressed vcf with:
```{r}
library(tidypopgen)
vcf_path <- system.file("/extdata/anolis/punctatus_t70_s10_n46_filtered.recode.vcf.gz",
                        package = "tidypopgen")
anole_vcf <- vcfR::read.vcfR(vcf_path)
anole_gt <- as_gen_tibble(anole_vcf)
anole_gt
```

Let us simplify the ids, which wll have a "punc_" prefix
```{r}
anole_gt <- anole_gt %>% mutate(id = gsub('punc_',"",.data$id,))

```

We can see that we have 46 individuals, from 3249 loci. Note that we don't have any
information on population from the vcf. That information can be found
from another file on the github repository ("https://github.com/ivanprates/2018_Anolis_EcolEvol/raw/master/data/plot_order_punctatus_n46.csv).
We will have add the population information manually. Let's start by reading the
file:
```{r}
pops_path <- system.file("/extdata/anolis/plot_order_punctatus_n46.csv",
                        package = "tidypopgen")
pops <- readr::read_csv(pops_path)
pops
```

The ids from the VCF are in a different format than the ones we just got from
the pop csv. We need a bit of string wrangling, but it looks easy, we just need
to remove "punc_":

Let us simplify the ids, which wll have a "punc_" prefix
```{r}
anole_gt <- anole_gt %>% mutate(id = gsub('punc_',"",.data$id,))
anole_gt
```

Now we can bring in the pop information:
```{r}
anole_gt <- anole_gt %>% mutate(population = pops$pop[match(pops$ID,.data$id)])
anole_gt
```

That was easy. The loci had already been filtered and cleaned, so we don't need 
to do any QC. Let us jump straight into analysis and run a PCA:
```{r}
anole_pca <- anole_gt %>% gt_pca(center=TRUE)
anole_pca
```

Let us add the PC scores to our `gen_tibble` (since we have a small dataset,
we add them directly to the object, without dropping the genotypes):
```{r}
anole_gt <- augment(anole_pca , data = anole_gt, drop_genotypes = FALSE)
library(ggplot2)
anole_gt %>% ggplot(aes(.fittedPC1, .fittedPC2, color = population)) + 
  geom_point(size = 1.5)
```
We can see that the three population do separate nicely on the PCA.

# Explore population structure with DAPC

DAPC is a powerful tool to investigate population structure. It has the advantage of
scaling well to very large datasets, and it does not have the assumptions of STRUCTURE or
ADMIXTURE (but that can also be a drawback).

The first step is to determine the number of genetic clusters in the dataset. We will use
a k-clustering algorithm applied to the principal components (allowing us to reduce
the dimensions from the thousands of loci to just a few tens components). We need to decide how 
many components to use; this decision is often made based on a plot of the cumulative
explained variance of the components.
Using `tidy` on the `gt_pca` object allows us easily obtain those quantities, and it is then
trivial to plot them:
```{r}
library(ggplot2)
tidy(anole_pca,matrix="eigenvalues") %>%
  ggplot(mapping =aes(x=PC, y=cumulative)) +
  geom_point()

```

Ideally, we are looking for the point where the curve starts flattening. In this case, we can
not see a very clear flattening, but by component 35 the increments are pretty small. Another
way to think about this is to consider the number of components that explain a large amount
of variation. We can see that the first 17 components already explain over 90% of the variance.  We can also
get the number of components programmatically by using:
```{r}
tidy(anole_pca,matrix="eigenvalues") %>% filter(cumulative<0.9) %>% nrow() +1 
```

Note that there isn't anything magical about 90%, and you might use another threshold. In
general, it is worth exploring the sensitivity of the results to any of these decisions.
For this analysis, we will go with 17 components:

```{r}
anole_clusters <- gt_pca_find_clusters(anole_pca, n_pca = 17)
```

This object retains information about a large number of possible *k*. We can choose
the best k with `gt_pca_clust_choose_n()` (we will use the defaults, but there
are multiple statistics and criteria that we can use to choose *n*):
```{r}
anole_clusters <- gt_pca_clust_choose_n(anole_clusters)
```

Now we can run a DAPC:
```{r}
anole_dapc <- gt_dapc(anole_clusters)
```

Note that `gt_dapc()` takes automatically 3 clusters form the `anole_clusters` object,
but can change that behaviour by setting some of its parameters (see the help
page for `gt_dapc()`).
`anole_dapc` is of class `dapc`, so we can use the standard `adegenet` functions:
```{r}
anole_dapc
scatter(anole_dapc)
```


