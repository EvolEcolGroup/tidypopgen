---
title: "example workflow with tidypopgen"
output: rmarkdown::html_vignette
        #pdf_document
vignette: >
  %\VignetteIndexEntry{example_workflow}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```


# Ideally redo this with a dataset that does have some intermediates (e.g. subset from the HGDP)

## An example workflow with real data
We will us the example dataset from `vigsnpr`:
:
```{r}
library(tidypopgen)
library(bigsnpr)
bedfile <- system.file("extdata", "example.bed", package = "bigsnpr")
snp_file <- snp_readBed(bedfile, backingfile = tempfile())
example_gt <- gen_tibble(snp_file)
```

Let us explore our table:
```{r}
example_gt
```

We can now explore the data a little bit. We could estimate observed heterozygosity:
```{r}
example_gt %>% group_by(population) %>% ind_het_obs()
```


That was easy. The loci had already been filtered and cleaned, so we don't need 
to do any QC. Let us jump straight into analysis and run a PCA:
```{r}
example_pca <- example_gt %>% gt_pca()
```

We can get a quick summary of the resulting object:
```{r}
example_pca
```

Let us add the PC scores to our `gen_tibble`, and plot them:
```{r}
library(ggplot2)
example_pca %>% 
  augment( data = example_gt, k=2) %>%
  ggplot(aes(.fittedPC1, .fittedPC2, color = population)) + 
  geom_point(size = 1.5)
```
We can see that the population do separate nicely into 3 main groups on the PCA.

# Explore population structure with DAPC

DAPC is a powerful tool to investigate population structure. It has the advantage of
scaling well to very large datasets, and it does not have the assumptions of STRUCTURE or
ADMIXTURE (but that can also be a drawback).

The first step is to determine the number of genetic clusters in the dataset. We will use
a k-clustering algorithm applied to the principal components (allowing us to reduce
the dimensions from the thousands of loci to just a few tens components). We need to decide how 
many components to use; this decision is often made based on a plot of the cumulative
explained variance of the components.
Using `tidy` on the `gt_pca` object allows us easily obtain those quantities, and it is then
trivial to plot them:
```{r}
library(ggplot2)
tidy(example_pca,matrix="eigenvalues") %>%
  ggplot(mapping =aes(x=PC, y=cumulative)) +
  geom_point()

```

Ideally, we are looking for the point where the curve starts flattening. As we only extracted
10 components (the default), we can see that the cumulative variance keeps increasing. We
have to go back and compute more components:
```{r}
example_pca <- example_gt %>% gt_pca(k=200)
```

And plot it again:
```{r}
library(ggplot2)
tidy(example_pca,matrix="eigenvalues") %>%
  ggplot(mapping =aes(x=PC, y=cumulative)) +
  geom_point()

```

In this case, we can see that even with 200 components, we do not see a very clear flattening. Another
way to think about this is to consider the number of components that explain a large amount
of variation. We can get the number of components that explain at least 90% of variance with:
```{r}
tidy(example_pca,matrix="eigenvalues") %>% filter(cumulative<0.9) %>% nrow()+1 
```

Note that there isn't anything magical about 90%, and you might use another threshold. In
general, it is worth exploring the sensitivity of the results to any of these decisions.
For this analysis, we will go with 17 components:

```{r}
example_clusters <- gt_pca_find_clusters(example_pca, n_pca = 165)
```

This object retains information about a large number of possible *k*. We can choose
the best k with `gt_pca_clust_choose_n()` (we will use the defaults, but there
are multiple statistics and criteria that we can use to choose *n*):
```{r}
example_clusters <- gt_pca_best_k(example_clusters)
```

Now we can run a DAPC:
```{r eval=FALSE}
example_dapc <- gt_dapc(example_clusters)
```

Note that `gt_dapc()` takes automatically 3 clusters form the `example_clusters` object,
but can change that behaviour by setting some of its parameters (see the help
page for `gt_dapc()`).
`example_dapc` is of class `dapc`, so we can use the standard `adegenet` functions:
```{r eval=FALSE}
example_dapc
scatter(example_dapc)
```
We can inspect the assignment by DAPC with `assignplot`, ordering the samples
by the original population label:
```{r eval=FALSE}
assignplot(example_dapc,subset=order(example_gt$population))
```


As one would expect from the clear separation in the PCA and DAPC scatterplots,
individuals are all fully assigned to a single cluster, with no individual with
mixed ancestry.

```{r eval=FALSE}
compoplot(example_dapc, subset=order(example_gt$population), posi="bottomright",
txt.leg=paste("Cluster", 1:3), lab="",
ncol=2, xlab="individuals", col=funky(3))
```
