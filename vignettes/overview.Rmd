---
title: "overview"
output: #rmarkdown::html_vignette
        pdf_document
vignette: >
  %\VignetteIndexEntry{overview}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## tidy data in population genetics

The fundamental tenet of tidy data that is that each observation should have its
own row and each variable its own column, such that each value has its own cell.
Applying this logic to population genetic data means that each individual should
have its own row, with individual metadata (such as its population, sex, phenotype, etc)
as the variables. Genotypes for each locus can also be thought as variables, however, due
to the large number of loci and the restricted values that each genotype can take, it would
be very inefficient to store them as individual standard columns. 

In `tidypopgen`, we represent data as a `gen_tbl`, a subclass of `tibble` which has
four compulsory columns: `id` of the individual (as a `character`, which must 
be unique for each individual), `population` giving the population the 
individuals belong to (a `factor`), and `genotypes` (stored in a compressed format
as a list, one
object per individual representing its genotypes for all loci). 
In order to define the loci stored in the compressed objects in the `genotype` list,
we also require an additional tibble stored as the attribute `loci` to the column `genotypes`. 
The `loci` tibble includes columns
`name` for the locus name (a `character`, which must be unique), `chromosome` for the chromosome (`a factor`, if known, 
otherwise set to `NA`), `position` for the position on the chromosome (`numeric`, if known, 
otherwise set to `NA`), `allele_ref` for the the reference allele (a character),
and `allele_alt` for the alternate allele (a character, which can be `NA` for
monomorphic loci). Additional individual metadata can be stored as columns in
the main `gen_tbl`, whilst additional loci information (such as the position in 
centimorgans) can be added as columns in the `loci` attribute table.

In principle, it is possible to use use multiple ways to compress the genotypes.
`tidypopgen` currently uses `SNPBin` from the package `adegenet`. It is very
memory efficient, and it is flexible in representing multiple ploidy. But the
infrastructure is present to adopt alternative compression approaches in the future
the only constraint is that the data have to be representable as a list of n elements
where n is the number of individuals (i.e. one object per individual).

## The grammar of population genetics

### The `gen_tibble`

Given information about the individuals, their genotypes, and the loci:
```{r}
test_ind_meta <- data.frame (id=c("a","b","c"),
                       population = c("pop1","pop1","pop2"))
test_genotypes <- rbind(c(1, 1, 0, 1, 1, 0), 
                        c(2, 0, 0, 0,NA, 0), 
                        c(1, 2, 0, 0, 1, 1))
test_loci <- data.frame(name=c("rs1","rs2","rs3","rs4","x1","x2"),
                   chromosome=c(1,1,1,1,2,2),
                   position=c(3,5,65,343,23,456),
                   allele_ref = c("a","t","c","g","c","t"),
                   allele_alt = c("t","c", NA,"c","g","a"))
```

We can create a simple `gen_tibble` object (of class `gen_tbl`) with
```{r}
library(tidypopgen)
test_gen <- gen_tibble(test_ind_meta, test_genotypes, test_loci)
test_gen
```
As discussed above, in this tibble, genotypes are stored as a list of 
compressed `SNPbin` objects.

Note that, since ploidy was not defined, it defaulted to 2:
```{r}
test_gen %>% show_ploidy()
```
For different ploidy, just provide a vector of values to the parameter `ploidy`
in `gen_tibble`.

Note that, if we are passing a `gen_tibble` to a function that works on
genotypes, it is not necessary to pass the column `genotypes` in the call.
However, if such a function is used within a `dplyr` verb such as `mutate`,
we need to pass the `genotype` column to the function:

```{r}
test_gen %>% mutate (ploidy = show_ploidy(.data$genotypes))
```
Or, more simply:
```{r}
test_gen %>% mutate (ploidy = show_ploidy(genotypes))
```

To retrieve the genotypes (which are compressed), we use:
```{r}
test_gen %>% show_genotypes()
```

If we want to extract the information about the loci for which we have genotypes
(which are stored as an attribute of that column),
we say:
```{r}
test_gen %>% show_loci()
```

## Standard `dplyr` verbs to manipulate the tibble

The individual metadata can then be processed with the usual `tidiverse` grammar.
So, we can filter individuals by population with
```{r}
test_pop1 <- test_gen %>% filter (population=="pop1")
test_pop1
```

There are a number of functions that compute population genetics quantities for each
individual, such as individual observed heterozygosity. We can compute them simply with:
```{r}
test_gen %>% ind_H_obs()
```

We can use `mutate` to add observed heterozygosity as a column to our
`gen_tibble` (again, note that functions that work on genotypes don't need
to be passed any arguments if the tibble is passed directly to them, but
the column `genotypes` has to be provided when they are used within
`dplyr` verbs such as `mutate`):
```{r}
test_gen %>% mutate(het_obs = ind_H_obs(genotypes))
```

# Using verbs on loci

Since the genotypes of the loci are stored as a compressed list in one column,
it is not possible to use standard `dplyr` verbs on them. However, `tidypopgen` provides
a number of specialised verbs, postfixed by `_loci`, to manipulate loci. 

A key operation on loci is their selection (and removal). The compressed nature
of genotypes imposes some constraints on the possible grammar.
For selection, there are two verbs: `select_loci` and `select_loci_if`. 
`select_loci` understands the concise-minilanguage spoken by standard `dplyr::select`
that allows to easily refer to variables by their names. However, `select_loci`
criteria can not be based on the actual genotypes (e.g. on heterozygosity or 
missingness). For that, we have to use `select_loci_if`, which can operate on the
genotypes but is blind to the names of loci.

Let us start by looking at the loci names in our simple dataset:
```{r}
show_loci_names(test_gen)

```

We can see that there are two categories of loci, one starting with "rs" and
the other with "x". If we wanted to select only loci that have an "rs" code,
we would use:
```{r}
test_sub <- test_gen %>% select_loci (starts_with("rs"))
test_sub
```
This gives us a `gen_tibble` with only 4 loci, as expected. We can confirm that
we have the correct loci with:
```{r}
show_loci_names(test_sub)
```

We can also subset and reorder by passing indeces (note that we extract the loci
information, but in reality we have reordered and subsetted the genotypes
for all individuals):
```{r}
test_gen %>% select_loci (c(2,6,1)) %>% show_loci()
```
This operation could be helpful when merging datasets that do not fully
overlap on their loci (more on that later).

The limit of `select_loci` is that it can not directly summarise the genotypes.
We can do that separately and then feed the result as a set of indeces. For 
example, we might want to impose a minimum minor allele frequency. 
`loci_freq()` allows us to inspect the frequencies in a `gen_tibble`: 
```{r}
test_gen %>% loci_freq()
```

We can now create a vector of indices of loci with a minimum allele frequency
(MAF) larger than 0.2, and use it to select:

```{r}
sel_indices <- which((test_gen %>% loci_freq())>0.2)
test_gen %>% select_loci (all_of(sel_indices)) %>% show_loci()
```

Note that passing a variable direclty to `select` is deprecated, and so we have
to use `all_of` to wrap it.

`select_loci_if` allows us to avoid creating a temporary variable to store indices:

```{r}
test_gen_sub <- test_gen %>% select_loci_if(loci_freq(genotypes)>0.2)
test_gen_sub %>% show_genotypes()
```

Note that, as we need to tidy evaluate `loci_freq` within the `select_loci_if` verb,
we need to provide it with the column that we want to use (even though it has
to be `genotypes`). Also note that, with `select_loci_if`, we can not reorder
the loci.

`select_loci_if` is very flexible; for example, we could filter loci with a MAF
greater than 0.2 that are also on chromosome 2

We can use a similar approach to select only alleles on a given chromosome:
```{r}
test_gen %>% select_loci_if(show_loci(genotypes)$chromosome==2 &
                             loci_freq(genotypes)>0.2) %>% show_loci()
```

# Grouping individuals in populations

In population genetics, we are generally interested in computing quantities that
describe groups of individuals (i.e. populations). Grouping can be used in a 
number of ways.

For functions that return one result per individual (such as
`ind_H_obs` that we used before), we can use summarise, which returns a
new `tibble` with one line per population. For example, we can count the number of individuals 
per population, as well as their mean heterozygosity with :
```{r}
test_gen %>% group_by(population) %>% 
  summarise(n= n(), mean_het = mean(ind_H_obs(genotypes)))
```

For functions that return a quantity per locus (e.g. `loci_freq`), we can use 
 `group_by` together with `group_map` to apply such functions over populations:
```{r}
test_gen %>% group_by(population) %>% group_map(.f = ~loci_freq(.x))
```

For more details on the syntax of `group_map`, see its help page. Some 
functions, such as `loci_freq()`, also have a method for grouped tibbles that 
allows an even easier syntax:

```{r}
test_gen %>% group_by(population) %>% loci_freq()
```

In reality, such grouped methods are nothing more than a wrapper for the
the appropriate `group_map` syntax, but they do make life a little bit simpler.


# Reading data

Currently, `tidypopgen` can read data only from PLINK raw files generated with 
the flags `--include-alt` and `--recodeA`.

```{r}
raw_path <- system.file("extdata/pop_a.raw", package = "tidypopgen")
map_path <- system.file("extdata/pop_a.map", package = "tidypopgen")
plink_gen_tbl <- read_plink_raw(file = raw_path, map_file = map_path)
plink_gen_tbl
```
