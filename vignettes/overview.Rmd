---
title: "overview"
output: #rmarkdown::html_vignette
        pdf_document
vignette: >
  %\VignetteIndexEntry{overview}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## tidy data in population genetics

The fundamental tenet of tidy data that is that each observation should have its
own row and each variable its own column, such that each value has its own cell.
Applying this logic to population genetic data means that each individual should
have its own row, with individual metadata (such as its population, sex, phenotype, etc)
as the variables. Genotypes for each locus can also be thought as variables, however, due
to the large number of loci and the restricted values that each genotype can take, it would
be very inefficient to store them as individual standard columns. 

In `tidypopgen`, we represent data as a `gen_tbl`, a subclass of `tibble` which has
four compulsory columns: `id` of the individual (as a `character`, which must 
be unique for each individual), `population` giving the population the 
individuals belong to (a `factor`), and `genotypes` (stored in a compressed format
as a list, one
object per individual representing its genotypes for all loci). 
In order to define the loci stored in the compressed objects in the `genotype` list,
we also require an additional tibble stored as the attribute `loci` to the column `genotypes`. 
The `loci` tibble includes columns
`name` for the locus name (a `character`, which must be unique), `chromosome` for the chromosome (`a factor`, if known, 
otherwise set to `NA`), `position` for the position on the chromosome (`numeric`, if known, 
otherwise set to `NA`), `allele_ref` for the the reference allele (a character),
and `allele_alt` for the alternate allele (a character, which can be `NA` for
monomorphic loci). Additional individual metadata can be stored as columns in
the main `gen_tbl`, whilst additional loci information (such as the position in 
centimorgans) can be added as columns in the `loci` attribute table.

In principle, it is possible to use use multiple ways to compress the genotypes.
`tidypopgen` currently uses `SNPBin` from the package `adegenet`. It is very
memory efficient, and it is flexible in representing multiple ploidy. But the
infrastructure is present to adopt alternative compression approaches in the future
the only constraint is that the data have to be representable as a list of n elements
where n is the number of individuals (i.e. one object per individual).

## The grammar of population genetics

### The `gen_tibble`

Given information about the individuals, their genotypes, and the loci:
```{r}
example_ind_meta <- data.frame (id=c("a","b","c"),
                       population = c("pop1","pop1","pop2"))
example_gtotypes <- rbind(c(1, 1, 0, 1, 1, 0), 
                        c(2, 0, 0, 0,NA, 0), 
                        c(1, 2, 0, 0, 1, 1))
example_loci <- data.frame(name=c("rs1","rs2","rs3","rs4","x1","x2"),
                   chromosome=c(1,1,1,1,2,2),
                   position=c(3,5,65,343,23,456),
                   allele_ref = c("a","t","c","g","c","t"),
                   allele_alt = c("t","c", NA,"c","g","a"))
```

We can create a simple `gen_tibble` object (of class `gen_tbl`) with
```{r}
library(tidypopgen)
example_gt <- gen_tibble(example_ind_meta, example_gtotypes, example_loci)
example_gt
```
As discussed above, in this tibble, genotypes are stored as a list of 
compressed `SNPbin` objects.

Note that, since ploidy was not defined, it defaulted to 2:
```{r}
example_gt %>% show_ploidy()
```
For different ploidy, just provide a vector of values to the parameter `ploidy`
in `gen_tibble`.

Note that, if we are passing a `gen_tibble` to a function that works on
genotypes, it is not necessary to pass the column `genotypes` in the call.
However, if such a function is used within a `dplyr` verb such as `mutate`,
we need to pass the `genotype` column to the function:

```{r}
example_gt %>% mutate (ploidy = show_ploidy(.data$genotypes))
```
Or, more simply:
```{r}
example_gt %>% mutate (ploidy = show_ploidy(genotypes))
```

To retrieve the genotypes (which are compressed), we use:
```{r}
example_gt %>% show_genotypes()
```

If we want to extract the information about the loci for which we have genotypes
(which are stored as an attribute of that column),
we say:
```{r}
example_gt %>% show_loci()
```

## Standard `dplyr` verbs to manipulate the tibble

The individual metadata can then be processed with the usual `tidiverse` grammar.
So, we can filter individuals by population with
```{r}
example_pop1 <- example_gt %>% filter (population=="pop1")
example_pop1
```

There are a number of functions that compute population genetics quantities for each
individual, such as individual observed heterozygosity. We can compute them simply with:
```{r}
example_gt %>% ind_H_obs()
```

We can use `mutate` to add observed heterozygosity as a column to our
`gen_tibble` (again, note that functions that work on genotypes don't need
to be passed any arguments if the tibble is passed directly to them, but
the column `genotypes` has to be provided when they are used within
`dplyr` verbs such as `mutate`):
```{r}
example_gt %>% mutate(het_obs = ind_H_obs(genotypes))
```

# Using verbs on loci

Since the genotypes of the loci are stored as a compressed list in one column,
it is not possible to use standard `dplyr` verbs on them. However, `tidypopgen` provides
a number of specialised verbs, postfixed by `_loci`, to manipulate loci. 

A key operation on loci is their selection (and removal). The compressed nature
of genotypes imposes some constraints on the possible grammar.
For selection, there are two verbs: `select_loci` and `select_loci_if`. 
`select_loci` understands the concise-minilanguage spoken by standard `dplyr::select`
that allows to easily refer to variables by their names. However, `select_loci`
criteria can not be based on the actual genotypes (e.g. on heterozygosity or 
missingness). For that, we have to use `select_loci_if`, which can operate on the
genotypes but is blind to the names of loci.

Let us start by looking at the loci names in our simple dataset:
```{r}
show_loci_names(example_gt)

```

We can see that there are two categories of loci, one starting with "rs" and
the other with "x". If we wanted to select only loci that have an "rs" code,
we would use:
```{r}
example_sub <- example_gt %>% select_loci (starts_with("rs"))
example_sub
```
This gives us a `gen_tibble` with only 4 loci, as expected. We can confirm that
we have the correct loci with:
```{r}
show_loci_names(example_sub)
```

We can also subset and reorder by passing indeces (note that we extract the loci
information, but in reality we have reordered and subsetted the genotypes
for all individuals):
```{r}
example_gt %>% select_loci (c(2,6,1)) %>% show_loci()
```
This operation could be helpful when merging datasets that do not fully
overlap on their loci (more on that later).

The limit of `select_loci` is that it can not directly summarise the genotypes.
We can do that separately and then feed the result as a set of indeces. For 
example, we might want to impose a minimum minor allele frequency. 
`loci_freq()` allows us to inspect the frequencies in a `gen_tibble`: 
```{r}
example_gt %>% loci_freq()
```

We can now create a vector of indices of loci with a minimum allele frequency
(MAF) larger than 0.2, and use it to select:

```{r}
sel_indices <- which((example_gt %>% loci_freq())>0.2)
example_gt %>% select_loci (all_of(sel_indices)) %>% show_loci()
```

Note that passing a variable direclty to `select` is deprecated, and so we have
to use `all_of` to wrap it.

`select_loci_if` allows us to avoid creating a temporary variable to store indices:

```{r}
example_gt_sub <- example_gt %>% select_loci_if(loci_freq(genotypes)>0.2)
example_gt_sub %>% show_genotypes()
```

Note that, as we need to tidy evaluate `loci_freq` within the `select_loci_if` verb,
we need to provide it with the column that we want to use (even though it has
to be `genotypes`). Also note that, with `select_loci_if`, we can not reorder
the loci.

`select_loci_if` is very flexible; for example, we could filter loci with a MAF
greater than 0.2 that are also on chromosome 2

We can use a similar approach to select only alleles on a given chromosome:
```{r}
example_gt %>% select_loci_if(show_loci(genotypes)$chromosome==2 &
                             loci_freq(genotypes)>0.2) %>% show_loci()
```

Sometimes it is also of interest to use a particular type of allele (the minor or
the major) when representing gentoypes, either for specific analysis 
or for exporting data. The representation 
we have used so far is arbitrary, but we can use an additional feature of 
`select_loci` and `select_loci_if` to swap the reference and alternate allele.
Both functions include a `.swap_arg` and a `.swap_if_arg`. We case use either
of those parameters to perform select-like operations that define which loci are
swapped. `.swap_arg` is equivalent to `select_loci` in using the `select` mini-grammar
on loci name (but it is blidn to genotype content), whilst `.swap_if_arg` works 
like `select_loci_if` (having access to the genotyes but not the names).

Let us look at the genotypes in our dataset:
```{r}
example_gt %>% show_genotypes()
```

We can see that they are a mix of major and minor allele counts. We can turn
them into minor allele counts simply with:
```{r}
example_gt %>% 
  select_loci(everything(),
              .swap_if_arg = loci_freq(genotypes, minor=FALSE)>0.5) %>%
  show_genotypes()
```

Note that we use `minor=FALSE` in `loci_freq` to get the raw frequencies (earlier,
we used the default `minor=TRUE` which returns the minor allele frequencies). In
this case we selected all loci (`everything`). Alternatively, we could 
generate major allele frequencies only for SNPs with an `rs` code:

```{r}
example_gt %>% 
  select_loci(starts_with("rs"),
              .swap_if_arg = loci_freq(genotypes, minor=FALSE)<0.5) %>%
  show_genotypes()

```

Or only select and simultaneously swap all alleles on chromosome 2 (not sure
why you would want to do that, but it illustrates another combination of selecting
and swapping criteria:
```{r}
example_gt %>% 
  select_loci_if(show_loci(genotypes)$chromosome==2,
              .swap_if_arg = show_loci(genotypes)$chromosome==2) %>%
  show_genotypes()
```

# Grouping individuals in populations

In population genetics, we are generally interested in computing quantities that
describe groups of individuals (i.e. populations). Grouping can be used in a 
number of ways.

As a starting point, we can group by population and get pop sizes:
```{r}
example_gt %>% group_by(population) %>% tally()
```

For functions that return one result per individual (such as
`ind_H_obs` that we used before), we can use summarise, which returns a
new `tibble` with one line per population. For example, we can count the number of individuals 
per population, as well as their mean heterozygosity with :
```{r}
example_gt %>% group_by(population) %>% 
  summarise(n= n(), mean_het = mean(ind_H_obs(genotypes)))
```

For functions that return a quantity per locus (e.g. `loci_freq`), we can use 
 `group_by` together with `group_map` to apply such functions over populations:
```{r}
example_gt %>% group_by(population) %>% group_map(.f = ~loci_freq(.x))
```

For more details on the syntax of `group_map`, see its help page. Some 
functions, such as `loci_freq()`, also have a method for grouped tibbles that 
allows an even easier syntax:

```{r}
example_gt %>% group_by(population) %>% loci_freq()
```

In reality, such grouped methods are nothing more than a wrapper for the
the appropriate `group_map` syntax, but they do make life a little bit simpler.

Certain metrics and analysis are naturally defined by a grouped tibble, such as
distance metrics among populations. For example:

```{r}
example_gt %>% group_by(population) %>% gt_pairwise_fst()

```

# Reading and exporting data

Currently, `tidypopgen` can read data only from PLINK raw files generated with 
the flags `--include-alt` and `--recodeA`.

```{r}
raw_path <- system.file("extdata/pop_a.raw", package = "tidypopgen")
map_path <- system.file("extdata/pop_a.map", package = "tidypopgen")
plink_gt <- read_plink_raw(file = raw_path, map_file = map_path)
plink_gt
```

It can export data in the same format. We will save the dataset to
a file in the temporary directory:
```{r}
out_file <- tempfile()
gt_write_plink(plink_gt, file = out_file)
```

This will write both a `.raw` file as well as a `.map` file

Alternatively, we can write a plink `.ped` instead ofa `.raw` file with:
```{r}
gt_write_plink(plink_gt, file = out_file, plink_format = "ped")
```

It is also possible to convert back and from from `adegenet::genelight` objects, which are
well integrated into a number of existing packages to explore the data with, for example, PCA and
clustering, as well as a wealth of export possibilities.

```{r}
plink_gl <- as_genlight(plink_gt)
plink_gl
```
And back to `gen_tibble` (note that we have lost the additional metadata (such
as sex) which are not coded in `genlight` objects:
```{r}
plink_back_gt <- as_gen_tibble(plink_gl)
plink_back_gt

```

# Merging data

Merging data from different sources is a common problem, especially in human population
genetics where there is a wealth of SNP chips available. In `tidypopgen`, merging is
enacted with an `rbind` operation between `gen_tibbles`. If the datasets have the same
loci, then the merge is trivial. If not, then it is necessary to subset to the same
loci, and ensure that the data are coded with the same reference and alternate 
alleles (or swap if needed). Additionally, if data come from SNP chips, there is
the added complication that the strand is not always consistent, so it might also
be necessary to flip strand (in that case, ambiguous SNPs have to be filtered).
The `rbind` method for `gen_tibbles` has a number of parameters that allow us to
control the behaviour of the merge.

Let us start by bringing in an additional dataset:
```{r}
raw_path2 <- system.file("extdata/pop_b.raw", package = "tidypopgen")
map_path2 <- system.file("extdata/pop_b.map", package = "tidypopgen")
plink_gt2 <- read_plink_raw(file = raw_path2, map_file = map_path2)
plink_gt2
```

Here we are using very small datasets, but in real life, `rbind` operations
are very demanding. Before performing such an operation, we can run
`rbind_dry_run`:
```{r}
report <- rbind_dry_run(plink_gt, plink_gt2, flip_strand = TRUE,
                        remove_ambiguous = TRUE)
```

Note that, by default, `rbind` will NOT flip strand or remove ambiguous SNPs
(as they are only relevant when merging different SNP chips),
you need to set those options to TRUE if you want to use them.

The report object contains details about why each locus was either kept 
or removed, but usually the report is sufficient to make decisions on whether
we want to go ahead. If we are happy with the likely outcome, we can
proceed with the `rbind`:
```{r}
plink_merged <- rbind(plink_gt, plink_gt2, flip_strand = TRUE,
                        remove_ambiguous = TRUE)

```

We can look at the subsetted loci (using the first population as reference to
determine the strand and order of alleles):
```{r}
plink_merged %>% show_loci()
```

# Population genetics analyses

Besides using various metrics to describe populations, we often want to perform
more complex analyses, such as Principal Component Analysis or clustering. 

For example, we can ran a PCA with:

```{r}
pca_merged <- plink_merged %>% gt_pca(nf=2)
pca_merged
```
Note that the object has both class `gt_pca` and `glPca` (the class for PCA
from `genlight` objects from the `adegenet` package). This means that we can
use all functions from the `adegenet` package for exploring the PCA. E.g.:
```{r}
scatter(pca_merged)
```
In the future, we will add methods to `broom` and `augment` this object, but for
the moment refer to the `adegenet` tutorials and help pages to see how you can modify
the plots.

