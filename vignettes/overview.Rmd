---
title: "overview"
output: rmarkdown::html_vignette
        #pdf_document
vignette: >
  %\VignetteIndexEntry{overview}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## tidy data in population genetics

The fundamental tenet of tidy data that is that each observation should have its
own row and each variable its own column, such that each value has its own cell.
Applying this logic to population genetic data means that each individual should
have its own row, with individual metadata (such as its population, sex, phenotype, etc)
as the variables. Genotypes for each locus can also be thought as variables, however, due
to the large number of loci and the restricted values that each genotype can take, it would
be very inefficient to store them as individual standard columns. 

In `tidypopgen`, we represent data as a `gen_tbl`, a subclass of `tibble` which has
four compulsory columns: `id` of the individual (as a `character`, which must 
be unique for each individual), `population` giving the population the 
individuals belong to (a `factor`), and `genotypes` (stored in a compressed format
as a File-Backed Matrix, with the vector in the tibble providing the row indices of the matrix
for each individual). The real data reside on disk, and an attribute `bigsnp` of
the `genotype` column contains all the information to acess it. There is also an
additional attribute , `loci` which provides all the information about the loci,
including the column indices that represent in each locu in the FBM.
The vector of row indices and the table of loci can be subsetted and reordered without
changing the data on disk; thus, any operation on the `gen_tibble` is fast as it
shapes the indices of the genotyp matrix rather than the matrix itself.  
The `loci` tibble includes columns `big_index` for the index in the FBM,
`name` for the locus name (a `character`, which must be unique), `chromosome` for the chromosome (`a factor`, if known, 
otherwise set to `NA`), `position` for the position on the chromosome (`numeric`, if known, 
otherwise set to `NA`), `genetic_dist` for the gentic distance on the chromosome (`numeric`, if known, else set to 0) `allele_ref` for the the reference allele (a character),
and `allele_alt` for the alternate allele (a character, which can be `0` for
monomorphic loci, following the same convention as plink). Additional individual metadata can be stored as columns in
the main `gen_tbl`, whilst additional loci information (such as the position in 
centimorgans) can be added as columns in the `loci` attribute table.

[the class type of each column needs checking!!!]

In principle, it is possible to use use multiple ways to compress the genotypes.
`tidypopgen` currently uses `bigSNP` from the package `bigsnpr`. It is very
fast and well documented, but it is mostly geared towards diploid data. However,
with a bit of work it could be expanded to multiple ploidy. NOte that the
infrastructure is present to adopt alternative compression approaches in the future
the only constraint is that the data have to be representable as a list of n elements
where n is the number of individuals (i.e. one object per individual). For example,
we could keep the data in memory, and have a `SNPBin` object in each element of the list.

## The grammar of population genetics

### The `gen_tibble`

Given information about the individuals, their genotypes, and the loci:
```{r}
library(tidypopgen)
example_indiv_meta <- data.frame (id=c("a","b","c","d","e"),
                       population = c("pop1","pop1","pop2","pop2","pop2"))
example_genotypes <- rbind(c(1, 1, 0, 1, 1, 0), 
                        c(2, 0, 0, 0,NA, 0), 
                        c(1, 2, 0, 0, 1, 1),
                        c(0, 2, 0, 1, 2, 1),
                        c(1, 1,NA, 2, 1, 0))
example_loci <- data.frame(name=c("rs1","rs2","rs3","rs4","x1","x2"),
                           chromosome=c(1,1,1,1,2,2),
                           position=c(3,5,65,343,23,456),
                           genetic_dist = c(0,0,0,0,0,0),
                           allele_ref = c("A","T","C","G","C","T"),
                           allele_alt = c("T","C", NA,"C","G","A"))

```


We can create a simple `gen_tibble` object (of class `gen_tbl`) with
```{r}
example_gt <- gen_tibble(example_genotypes, 
                         indiv_meta = example_indiv_meta,
                         loci=example_loci,
                         backingfile = tempfile())
```
We are provided information on where the two files underlying the genotype information
are stored. As we don't want to keep the files, we used the tmp directory; normally
you will want to use your working directory so that the files will not be cleared
by R at the end of the session. It is important that these
files are not deleted or moved, as `gen_tibble` stores their paths for future use. 

Now let's have a look at our `gen_tibble`:
```{r}
example_gt
```

As discussed above, in this tibble, `genotypes` contains the indices of the
individuals in the FBM as values, and the FBM as an attribute.

To retrieve the genotypes (which are compressed in the FBM), we use:
```{r}
example_gt %>% show_genotypes()
```

If we want to extract the information about the loci for which we have genotypes
(which are stored as an attribute of that column),
we say:
```{r}
example_gt %>% show_loci()
```

Note that, if we are passing a `gen_tibble` to a function that works on
genotypes, it is generally not necessary to pass the column `genotypes` in the call:

```{r}
example_gt %>% indiv_het_obs()
```
However, if such a function is used within a `dplyr` verb such as `mutate`,
we need to pass the `genotype` column to the function:

```{r}
example_gt %>% mutate (het_obs = indiv_het_obs(.data$genotypes))
```
Or, more simply:
```{r}
example_gt %>% mutate (het_obs = indiv_het_obs(genotypes))
```



## Standard `dplyr` verbs to manipulate the tibble

The individual metadata can then be processed with the usual `tidiverse` grammar.
So, we can filter individuals by population with
```{r}
example_pop1 <- example_gt %>% filter (population=="pop2")
example_pop1
```

There are a number of functions that compute population genetics quantities for each
individual, such as individual observed heterozygosity. We can compute them simply with:
```{r}
example_gt %>% indiv_het_obs()
```

Or after filtering:
```{r}
example_gt %>% filter (population=="pop2") %>% indiv_het_obs()

```

We can use `mutate` to add observed heterozygosity as a column to our
`gen_tibble` (again, note that functions that work on genotypes don't need
to be passed any arguments if the tibble is passed directly to them, but
the column `genotypes` has to be provided when they are used within
`dplyr` verbs such as `mutate`):
```{r}
example_gt %>% mutate(het_obs = indiv_het_obs(genotypes))
```

# Using verbs on loci

Since the genotypes of the loci are stored as a compressed list in one column,
it is not possible to use standard `dplyr` verbs on them. However, `tidypopgen` provides
a number of specialised verbs, postfixed by `_loci`, to manipulate loci. 

A key operation on loci is their selection (and removal). The compressed nature
of genotypes imposes some constraints on the possible grammar.
For selection, there are two verbs: `select_loci` and `select_loci_if`. 
`select_loci` understands the concise-minilanguage spoken by standard `dplyr::select`
that allows to easily refer to variables by their names. However, `select_loci`
criteria can not be based on the actual genotypes (e.g. on heterozygosity or 
missingness). For that, we have to use `select_loci_if`, which can operate on the
genotypes but is blind to the names of loci.

Let us start by looking at the loci names in our simple dataset:
```{r}
show_loci_names(example_gt)
```

We can see that there are two categories of loci, one starting with "rs" and
the other with "x". If we wanted to select only loci that have an "rs" code,
we would use:
```{r}
example_sub <- example_gt %>% select_loci (starts_with("rs"))
example_sub
```
This gives us a `gen_tibble` with only 4 loci, as expected. We can confirm that
we have the correct loci with:
```{r}
show_loci_names(example_sub)
```

Let us check that this has indeed impacted the individual heterozygosity
```{r}
example_sub %>% indiv_het_obs()
```

We can also subset and reorder by passing indices:
```{r}
example_gt %>% select_loci (c(2,6,1)) %>% show_loci()
```
This operation could be helpful when merging datasets that do not fully
overlap on their loci (more on that later).

```{r}
example_gt %>% select_loci (c(2,6,1)) %>% show_genotypes()
```


The limit of `select_loci` is that it can not directly summarise the genotypes.
We can do that separately and then feed the result as a set of indices. For 
example, we might want to impose a minimum minor allele frequency. 
`loci_freq()` allows us to inspect the frequencies in a `gen_tibble`: 
```{r}
example_gt %>% loci_freq()
```

We can now create a vector of indices of loci with a minimum allele frequency
(MAF) larger than 0.2, and use it to select:

```{r}
sel_indices <- which((example_gt %>% loci_freq())>0.2)
example_gt %>% select_loci (all_of(sel_indices)) %>% show_loci()
```

Note that passing a variable direclty to `select` is deprecated, and so we have
to use `all_of` to wrap it.

`select_loci_if` allows us to avoid creating a temporary variable to store indices:

```{r}
example_gt_sub <- example_gt %>% select_loci_if(loci_freq(genotypes)>0.2)
example_gt_sub %>% show_genotypes()
```

Note that, as we need to tidy evaluate `loci_freq` within the `select_loci_if` verb,
we need to provide it with the column that we want to use (even though it has
to be `genotypes`). Also note that, with `select_loci_if`, we can not reorder
the loci.

`select_loci_if` is very flexible; for example, we could filter loci with a MAF
greater than 0.2 that are also on chromosome 2

We can use a similar approach to select only alleles on a given chromosome:
```{r}
example_gt %>% select_loci_if(show_loci(genotypes)$chromosome==2 &
                             loci_freq(genotypes)>0.2) %>% show_loci()
```


# Grouping individuals in populations

In population genetics, we are generally interested in computing quantities that
describe groups of individuals (i.e. populations). Grouping can be used in a 
number of ways.

As a starting point, we can group by population and get pop sizes:
```{r}
example_gt %>% group_by(population) %>% tally()
```

For functions that return one result per individual (such as
`ind_H_obs` that we used before), we can use summarise, which returns a
new `tibble` with one line per population. For example, we can count the number of individuals 
per population, as well as their mean heterozygosity with :
```{r}
example_gt %>% group_by(population) %>% 
  summarise(n= n(), mean_het = mean(indiv_het_obs(genotypes)))
```

However, note that this is somewhat inefficient, as computing the pop averages
requires multiple access to the data. A more efficient approach is to:
```{r}
example_gt %>% mutate(het_obs = indiv_het_obs(genotypes)) %>% group_by(population) %>% 
  summarise(n= n(), mean_het = mean(het_obs))
```

In this way, we compute all individual heterozygosities in one go (optimising
our file access time), and then generate the population summaries.

For functions that return a quantity per locus (e.g. `loci_freq`), we can use 
 `group_by` together with `group_map` to apply such functions over populations:
```{r}
example_gt %>% group_by(population) %>% group_map(.f = ~loci_freq(.x))
```

For more details on the syntax of `group_map`, see its help page. Some 
functions, such as `loci_freq()`, also have a method for grouped tibbles that 
allows an even easier syntax:

```{r}
example_gt %>% group_by(population) %>% loci_freq()
```

In reality, such grouped methods are nothing more than a wrapper for the
the appropriate `group_map` syntax, but they do make life a little bit simpler.

Certain metrics and analysis are naturally defined by a grouped tibble, such as
distance metrics among populations. For example:

```{r}
# not reimplemented yet!
example_gt %>% group_by(population) %>% gt_pairwise_fst()
```

# Saving and reading data

We can save a `gen_tibble` with `gt_save()`. This command will save a file with
extension `.gt`. Together with the `.rds` and `.bk` files, the `.gt` file include
all the information stored in the `gen_tibble`. Note that, whilst the `.rds` and `.bk`
file have to share name, the `.gt` file can be named differently (but, by default, if
no specific name is given, `gt_save` will use the same pattern as for the `.rds` 
and `.bk` file).

So, let us save our file:
```{r}
gt_file_name <- gt_save(example_gt)
gt_file_name

```

In a later session, we could reload the data with:
```{r}
new_example_gt <- gt_load(gt_file_name[1])
new_example_gt %>% show_genotypes()
```

We can see that our genotypes were recovered correctly.

As we saw at the beginning of this vignette, it is possible to create a `gen_tibble` with data
in data.frames and tibbles. We can use that function to wrangle data in various formats (including
from vcf files via `vcfR`), but more commonly SNP data are stored as PLINK bed files.
`gen_tibble` can directly read bed files:

```{r}
bed_path_pop_a <- system.file("extdata/pop_a.bed", package = "tidypopgen")
pop_a_gt <- gen_tibble(bed_path_pop_a, backingfile = tempfile("pop_a_"))
```

For this vignette, we don't want to keep files, so we are using again a temporary
path for the backing files, but in normal instances, we can simply
omit the `backinfile` parameter, and the `.rds` and `.bk` file will be saved with the same name and
path as the original `.bed` file.

We can also export data to a .bed file. Note that, from the main tibble, only information
on `id`, `population` and `sex` will be preserved (TODO think about the other elements
of a fam file):
```{r}
gt_write_plink(example_gt, bedfile =  tempfile("new_bed_"))
```

# Merging data

Merging data from different sources is a common problem, especially in human population
genetics where there is a wealth of SNP chips available. In `tidypopgen`, merging is
enacted with an `rbind` operation between `gen_tibbles`. If the datasets have the same
loci, then the merge is trivial. If not, then it is necessary to subset to the same
loci, and ensure that the data are coded with the same reference and alternate 
alleles (or swap if needed). Additionally, if data come from SNP chips, there is
the added complication that the strand is not always consistent, so it might also
be necessary to flip strand (in that case, ambiguous SNPs have to be filtered).
The `rbind` method for `gen_tibbles` has a number of parameters that allow us to
control the behaviour of the merge.

Let us start by bringing in two sample datasets (note that we use tempfiles
to store the data; in real applications, we will usually avoid defining
a backingfile and let the function create backing files where the bed file is
stored):
```{r}
bed_path_pop_a <- system.file("extdata/pop_a.bed", package = "tidypopgen")
bigsnp_path_a <- bigsnpr::snp_readBed(bed_path_pop_a, backingfile = tempfile("pop_a_"))
pop_a_gt <- gen_tibble(bigsnp_path_a)
bed_path_pop_b <- system.file("extdata/pop_b.bed", package = "tidypopgen")
bigsnp_path_b <- bigsnpr::snp_readBed(bed_path_pop_b, backingfile =  tempfile("pop_b_"))
pop_b_gt <- gen_tibble(bigsnp_path_b)
```

And inspect them:
```{r}
pop_a_gt
```

And the other one:
```{r}
pop_b_gt
```

Here we are using very small datasets, but in real life, `rbind` operations
are very demanding. Before performing such an operation, we can run
`rbind_dry_run`:
```{r}
report <- rbind_dry_run(pop_a_gt, pop_b_gt, flip_strand = TRUE)
```

Note that, by default, `rbind` will NOT flip strand or remove ambiguous SNPs
(as they are only relevant when merging different SNP chips),
you need to set `flip_strand` to TRUE.

The report object contains details about why each locus was either kept 
or removed, but usually the report is sufficient to make decisions on whether
we want to go ahead. If we are happy with the likely outcome, we can
proceed with the `rbind`. Note that the data will be saved to disk.
We can either provide a path and prefix, to which '.RDS' and '.bk' will be 
appended for the `bigSNP` file and its backing file; or let the function
save the files in the same path as the original backing file of the first object).

NOTE: In this vignette, we save to the temporary directory, but in real life you want to save in
a directory where you will be able to retrive the file at a later date!!!
```{r}
# #create merge
merged_gt <- rbind(pop_a_gt, pop_b_gt, flip_strand = TRUE,
                           backingfile = file.path(tempdir(),"gt_merged"))
```

Let's check the resulting `gen_tibble`:
```{r}
merged_gt
```
Note that the values in the genotype column (which corresponds to the id in the
FBM file) have changed to reflect that we have a new, larger FBM with both
datasets.

We can look at the subsetted loci (note that we used the first population as reference to
determine the strand and order of alleles):
```{r}
merged_gt %>% show_loci()
```

Again, note that the `big_index` values have changed compared to the original files,
as we generated a new FBM with the merged data. 

# Population genetics analyses
Besides using various metrics to describe populations, we often want to perform
more complex analyses, such as Principal Component Analysis or clustering. 

We will us the example dataset from `bigsnpr`:
```{r}
library(tidypopgen)
library(bigsnpr)
bedfile <- system.file("extdata", "example.bed", package = "bigsnpr")
example_gt <- gen_tibble(bedfile, backingfile = tempfile("example_bed"))
```

Let us explore our table:
```{r}
example_gt
```

Let's get an overview of the populations:
```{r}
example_gt %>% group_by(population) %>% tally()
```
The loci had already been QC, but not cleaned for LD. We will use a PCA method, ''autoSVD',
that is designed to deal with LD directly via clumping:
```{r}
example_pca <- example_gt %>% gt_pca_autoSVD()
```

We can get a quick summary of the resulting object:
```{r}
example_pca
```
Objects outputted by different packages and analyes can be difficult to manipulate.
The package `broom` from the `tidyverse` offers methods 
to easily extract information in form of tibbles (`tidy`) and merge some of those outputs with the
original data (`augment`).
`tidypopgen` implements such methods for objects created from its functions. So, 
we can tidy the results as we would do for a standard PCA object from `prcomp`.
For example, we can get the Eigen values with:
```{r}
tidy(example_pca, matrix="eigenvalues")
```

And the scores for each individual:
```{r}
tidy(example_pca)
```

Rather than wrangling the scores obtained in this way to match them to the
original data table, we can simply use `augment`:

```{r}
example_gt <- augment(example_pca , data= example_gt, k=2)
example_gt
```

We can then easily plot our data with:
```{r}
library(ggplot2)
example_gt %>% ggplot(aes(.fittedPC1, .fittedPC2, color = population)) + 
  geom_point(size = 1.5)
```
We can see that the population do separate nicely into 3 main groups on the PCA.

Note that a number of analysis, such as PCA, do not allow for missing data. Let
us consider such a dataset:
```{r}
bed_file <- system.file("extdata", "example-missing.bed", package = "bigsnpr")
missing_gt <- gen_tibble(bed_file,  backingfile = tempfile("missing_"))
missing_gt
```

If we attempt to run a PCA on this dataset, we get:
```{r, error = TRUE}
missing_pca <- missing_gt %>% gt_pca_autoSVD()
```

It is possible to obviate to this problem by filtering loci with missing data,
but that might lose a lot of loci. The alternative is to inpute the missing
the data. `tidypopgen` provides wrappers for two fast imputation approaches
available in `bigsnpr`, a simple imputation (`gt_impute_simple`) based on the frequency of the alleles
at each locus (by random sampling, or used the mean or mode), and more sophisticated
approach (`gt_impute_xgboost`) that uses boosted trees to try and predict the most likely genotype.
These methods are fine to impute a few missing genotypes, but they should not be used for any
sophisticated imputation (e.g. of low coverage genomes).

We use the simple approach to fix our dataset:
```{r}
missing_gt <- gt_impute_simple(missing_gt)
```
We can now run the analysis (but it fails because we have too few SNPs!!!!):
```{r, error=TRUE}
missing_pca <- missing_gt %>% gt_pca_autoSVD()
```

We can use a standard PCA:
```{r}
missing_pca <- missing_gt %>% gt_pca_partialSVD()
missing_pca
```
Note that the observed genotypes have been kept, and we can go back to using 
them (and thus have missing values) with:
```{r}
missing_gt <- missing_gt  %>% gt_set_imputed(FALSE)
```

