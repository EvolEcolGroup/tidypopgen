---
title: "overview"
output: #rmarkdown::html_vignette
        pdf_document
vignette: >
  %\VignetteIndexEntry{overview}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## tidy data in population genetics

The fundamental tenet of tidy data that is that each observation should have its
own row and each variable its own column, such that each value has its own cell.
Applying this logic to population genetic data means that each individual should
have its own row, with individual metadata (such as its population, sex, phenotype, etc)
as the variables. Genotypes for each locus can also be thought as variables, however, due
to the large number of loci and the restricted values that each genotype can take, it would
be very inefficient to store them as individual standard columns. 

In `tidypopgen`, we represent data as a `gen_tbl`, a subclass of `tibble` which has
four compulsory columns: `id` of the individual (as a `character`, which must 
be unique for each individual), `population` giving the population the 
individuals belong to (a `factor`), and `genotypes` (
using `SNPBin` to provide a compressed representation of all the genotypes, which
can be decompressed as needed). In order to define the loci stored in the `SNPBin` objects,
we also require an additional tibble stored as the attribute `loci` to the column `genotypes`. 
The `loci` tibble includes columns
`name` for the locus name (a `character`, which must be unique), `chromosome` for the chromosome (`a factor`, if known, 
otherwise set to `NA`), `position` for the position on the chromosome (`numeric`, if known, 
otherwise set to `NA`), `allele_ref` for the the reference allele (a character),
and `allele_alt` for the alternate allele (a character, which can be `NA` for
monomorphic loci). Additional individual metadata can be stored as columns in
the main `gen_tbl`, whilst additional loci information (such as the position in 
centimorgans) can be added as columns in the `loci` attribute table.

## The grammar of population genetics

### The `gen_tibble`

Given information about the individuals, their genotypes, and the loci:
```{r}
test_ind_meta <- data.frame (id=c("a","b","c"),
                       population = c("pop1","pop1","pop2"))
test_genotypes <- rbind(c(1, 1, 0, 1, 1, 0), 
                        c(2, 0, 0, 0,NA, 0), 
                        c(1, 2, 0, 0, 1, 1))
test_loci <- data.frame(name=paste0("rs",1:6),
                   chromosome=c(1,1,1,1,2,2),
                   position=c(3,5,65,343,23,456),
                   allele_ref = c("a","t","c","g","c","t"),
                   allele_alt = c("t","c", NA,"c","g","a"))
```

We can create a simple `gen_tibble` object (of class `gen_tbl`) with
```{r}
library(tidypopgen)
test_gen <- gen_tibble(test_ind_meta, test_genotypes, test_loci)
test_gen
```
As discussed above, in this tibble, genotypes are stored as a list of 
compressed `SNPbin` objects.

Note that, since ploidy was not defined, it defaulted to 2:
```{r}
test_gen %>% show_ploidy()
```
For different ploidy, just provide a vector of values to the parameter `ploidy`
in `gen_tibble`.

Note that, if we are passing a `gen_tibble` to a function that works on
genotypes, it is not necessary to pass the column `genotypes` in the call.
However, if such a function is used within a `dplyr` verb such as `mutate`,
we need to pass the `genotype` column to the function:

```{r}
test_gen %>% mutate (ploidy = show_ploidy(.data$genotypes))
```
Or, more simply:
```{r}
test_gen %>% mutate (ploidy = show_ploidy(genotypes))
```

To retrieve the genotypes (which are compressed), we use:
```{r}
test_gen %>% show_genotypes()
```

If we want to extract the information about the loci for which we have genotypes
(which are stored as an attribute of that column),
we say:
```{r}
test_gen %>% show_loci()
```

## Standard `dplyr` verbs to manipulate the tibble

The individual metadata can then be processed with the usual `tidiverse` grammar.
So, we can filter individuals by population with
```{r}
test_pop1 <- test_gen %>% filter (population=="pop1")
test_pop1
```

There are a number of functions that compute population genetics quantities for each
individual, such as individual observed heterozygosity. We can compute them simply with:
```{r}
test_gen %>% ind_H_obs()
```

We can use `mutate` to add observed heterozygosity as a column to our
`gen_tibble` (again, note that functions that work on genotypes don't need
to be passed any arguments if the tibble is passed directly to them, but
the column `genotypes` has to be provided when they are used within
`dplyr` verbs such as `mutate`):
```{r}
test_gen <- test_gen %>% mutate(het_obs = ind_H_obs(genotypes))
test_gen
```

We can group our `gen_tibble` by population and count the number of individuals 
per population, as well as their mean heterozygosity:
```{r}
test_gen %>% group_by(population) %>% summarise(n= n(), mean_het = mean(ind_H_obs(genotypes)))
```

# Using verbs on loci

Since the genotypes of the loci are stored as a compressed list in one column,
it is not possible to use standard `dplyr` verbs on them. However, `tidypopgen` provides
a number of specialised verbs, postfixed by `_loci`, to manipulate loci.

For example, we might want to impose a minimum minor allele frequency. 
`loci_freq()` allows us to inspect the frequencies in a `gen_tibble`: 
```{r}
test_gen %>% loci_freq()
```

We can then select the desired alleles (e.g. with MAF>=0.2) with:
```{r}
test_gen_sub <- test_gen %>% select_loci_if(loci_freq(genotypes)>0.2)
test_gen_sub %>% show_genotypes()
```

Note that, as we need to tidy evaluate `loci_freq` within a `select_*` verb,
we need to provide it with the column that we want to use (even though it has
to be `genotypes`).

We can map a function such as `loci_freq` over a grouped tibble with:
```{r}
test_gen %>% group_by(population) %>% group_map(.f=~loci_freq(.x))
```

Some functions, like `loci_freq()` have a method for grouped tibbles that 
allow an even easier syntax:

```{r}
test_gen %>% group_by(population) %>% loci_freq()
```

In reality, such grouped methods are nothing more than a wrapper for the
the appropriate `group_map` syntax, but they do make life a little bit simpler.


# Reading data

Currently, `tidypopgen` can read data only from PLINK raw files:

```{r}
raw_path <- system.file("extdata/san.raw", package = "tidypopgen")
map_path <- system.file("extdata/san.map", package = "tidypopgen")
san_gen_tbl <- read_plink_raw(file = raw_path, map_file = map_path)
san_gen_tbl
```
