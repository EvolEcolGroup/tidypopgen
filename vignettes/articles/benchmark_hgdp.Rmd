---
title: "Benchmark on the HGDP"
---



This vignette is a benchmark of a few key functions in the tidypopgen package.
The Human Genome Diversity Project (HGDP) SNP dataset is used for this
benchmark. This dataset includes 1043 individuals from 51 populations, typed
at ~650k loci.

We will run this benchmark on a machine with a GenuineIntel, Intel(R) Core(TM) Ultra 7 155H, 22 CPU
and  of RAM. However, we will limit the number of
cores used to 20. Parallelised functions within tidypopgen use an
`n_cores` argument for the user to set. However, to prevent a behind-the-scenes
inflation of the number of threads used (for example, in cases where dependency
                                         functions may automatically use all available cores) we need to set up
preferences at the beginning of the session. Specifically, we limit the
number of cores used by the parallelised BLAS library with
`bigparallelr::set_blas_ncores()`, and by the package data.table with
`data.table::setDTthreads()`.


``` r
n_cores <- 20

data.table::setDTthreads(n_cores)
bigparallelr::set_blas_ncores(n_cores)
```

We can now load the necessary libraries:


``` r
library(tidypopgen)
library(ggplot2)
```

Before running this benchmark, we need to download into the subdirectory
`data/hgdp/` the bed file `hgdp650.qc.hg19.bed` and the metadata file
`HGDPid_populations.txt`.


``` r
bed_path <- "./data/hgdp/hgdp650.qc.hg19.bed"
meta_info <- readr::read_tsv("./data/hgdp/HGDPid_populations.txt")
#> Rows: 1064 Columns: 6
#> ── Column specification ──────────────────────────────────────────────────────────────────────────────────────────
#> Delimiter: "\t"
#> chr (6): Id, Sex, population, Geographic_origin, Region, Pop7Groups
#> 
#> ℹ Use `spec()` to retrieve the full column specification for this data.
#> ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.
```

# Create gen_tibble object

Our first step is to load the HGDP data into a `gen_tibble` object, and add its
associated metadata.



``` r
hgdp <- gen_tibble(bed_path,
                   quiet = TRUE,
                   backingfile = tempfile("test_"),
                   n_cores = n_cores)
```

read_plink: 4.6s

Add metadata


``` r
hgdp <- hgdp %>% mutate(
  population = meta_info$population[match(hgdp$id, meta_info$Id)],
  region = meta_info$Region[match(hgdp$id, meta_info$Id)]
)
```

Let's confirm that we have read all the expected information:

``` r
hgdp
#> # A gen_tibble: 643733 loci
#> # A tibble:     1,043 × 4
#>    id         genotypes population    region
#>    <chr>     <vctr_SNP> <chr>         <chr> 
#>  1 HGDP00448          1 Biaka_Pygmies Africa
#>  2 HGDP00479          2 Biaka_Pygmies Africa
#>  3 HGDP00985          3 Biaka_Pygmies Africa
#>  4 HGDP01094          4 Biaka_Pygmies Africa
#>  5 HGDP00982          5 Mbuti_Pygmies Africa
#>  6 HGDP00911          6 Mandenka      Africa
#>  7 HGDP01202          7 Mandenka      Africa
#>  8 HGDP00927          8 Yoruba        Africa
#>  9 HGDP00461          9 Biaka_Pygmies Africa
#> 10 HGDP00451         10 Biaka_Pygmies Africa
#> # ℹ 1,033 more rows
```

# Loci Report

We can then call `qc_report_loci`. This function supplies minor allele
frequency, rate of missingness, and a Hardy-Weinberg exact p-value for each SNP.


``` r
loci_report <- qc_report_loci(hgdp)
```

loci_report: 3.6s

# Loci Plot

The resulting report can be observed using `autoplot`.



``` r
autoplot(loci_report, type = "all")
```

![plot of chunk autoplot_loci_report](figure/autoplot_loci_report-1.png)

# Filter Loci

Following this, we filter the loci to only including those with a minor allele
frequency over 0.05, and a missingness rate below 0.05.


``` r
to_keep_loci <-
  subset(loci_report, loci_report$maf > 0.05 & loci_report$missingness < 0.05)
hgdp <- hgdp %>% select_loci(to_keep_loci$snp_id)
```

filter_loci: 3.6s

# Individual Report

We can then call `qc_report_indiv` to supply observed heterozygosity per
individual, and rate of missingness per individual.


``` r
indiv_report <- qc_report_indiv(hgdp)
```

indiv_report: 10.8s



``` r
autoplot(indiv_report, type = "scatter")
```

![plot of chunk autoplot_indiv_report](figure/autoplot_indiv_report-1.png)


# Filter individuals

And we can filter individuals down to only include those with less than 1% of
their genotypes missing.



``` r
to_keep_indiv <- which(indiv_report$missingness < 0.01)
hgdp <- hgdp[to_keep_indiv, ]
```

filter_indiv: 6ms

# Impute data

Some functions, such as `loci_ld_clump` and the `gt_pca` functions, require that
there is no missingness in the dataset, so we use `gt_impute_simple` to impute
any remaining missing genotypes.



``` r
hgdp <- gt_impute_simple(hgdp, method = "mode", n_cores = n_cores)
#> Error in gt_impute_simple(hgdp, method = "mode", n_cores = n_cores): The number of individuals in the gen_tibble does not match the number of rows in the file backing matrix. Before imputing, use gt_update_backingfile to update your file backing matrix.
gt_set_imputed(hgdp, TRUE)
#> Error in gt_set_imputed(hgdp, TRUE): this dataset does not have imputed values to use!
```

impute: 19ms

# LD clumping

LD clumping is then performed to control for linkage disequilibrium.


``` r
hgdp <- hgdp %>%
  select_loci_if(loci_ld_clump(genotypes, thr_r2 = 0.2, n_cores = n_cores))
```

ld_clumping: 15.2s

# PCA

A principal components analysis can then be computed using the resulting cleaned
and LD clumped dataset.



``` r
test_pca <- hgdp %>% gt_pca_partialSVD()
#> Error in if (any_near0(ms$scale)) stop2(MSG_ZERO_SCALE): missing value where TRUE/FALSE needed
```

pca: 865ms

Plot PCA:


``` r
autoplot(test_pca, type = "scores") +
  aes(color = hgdp$region, shape = hgdp$region)
#> Error in `geom_point()`:
#> ! Problem while computing aesthetics.
#> ℹ Error occurred in the 1st layer.
#> Caused by error in `check_aesthetics()`:
#> ! Aesthetics must be either length 1 or the same as the data (1043).
#> ✖ Fix the following mappings: `colour` and `shape`.
```

# DAPC

We can continue with a discriminant analysis of principal
components using `gt_dapc`.


``` r
pop_factor <- as.factor(hgdp$population)
test_dapc <- gt_dapc(test_pca, pop = pop_factor)
#> Error in lda.default(x, grouping, ...): nrow(x) and length(grouping) are different
```

dapc: 63ms

Plot DAPC:


``` r
autoplot(test_dapc, type = "screeplot")
```

![plot of chunk DAPC_screeplot](figure/DAPC_screeplot-1.png)

# Calculate Fst

To examine the differentiation between populations in the global HGDP set, we
calculate pairwise Fst.



``` r
grouped_hgdp <- hgdp %>% group_by(population)
pairwise_fsts <- grouped_hgdp %>% pairwise_pop_fst(n_cores = n_cores, tidy = FALSE)
```

pairwise_fst: 29.8s

Plot pairwise Fst:


``` r
# Order by continents
grouped_hgdp_order <- grouped_hgdp %>% arrange(region,population)
regional_order <- unique(grouped_hgdp_order$population)
pairwise_fsts <- pairwise_fsts[regional_order,regional_order]

ggheatmap(pairwise_fsts) +
  scale_fill_viridis_c()+
    theme(axis.text.x = element_text(angle = -60, hjust = 0, size = 6),
          axis.text.y = element_text(angle = 0, hjust = 1, size = 6))+
  labs(
    x = element_blank(),
    y = element_blank(),
    fill = "Fst"
  )
#> → heatmap built with `geom_tile()`
```

![plot of chunk pairwise_fst_plot](figure/pairwise_fst_plot-1.png)


# Save in plink bed format

Finally, we can save the resulting cleaned dataset to a PLINK .bed file.



``` r
gt_as_plink(hgdp,
            file = tempfile(),
            type = "bed",
            overwrite = TRUE)
#> [1] "/tmp/Rtmp5CBsmX/file121c217dc9069.bed"
```

plink_save: 1s

# Summary

Here is a summary of the time taken (in seconds) to perform each step of the analyses:


```
#>            step  time
#> 1    read_plink  4.55
#> 2   loci_report  3.59
#> 3   filter_loci  3.57
#> 4  indiv_report 10.75
#> 5  filter_indiv  0.01
#> 6        impute  0.02
#> 7   ld_clumping 15.25
#> 8           pca  0.86
#> 9          dapc  0.06
#> 10 pairwise_fst 29.79
#> 11   plink_save  1.01
#> 12        Total 69.46
```

