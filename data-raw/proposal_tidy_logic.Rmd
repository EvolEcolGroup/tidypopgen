---
title: "tidypopgen overview"
author: "Andrea Manica"
date: "2024-02-27"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## tidy data in population genetics

The fundamental tenet of tidy data that is that each observation should have its
own row and each variable its own column, such that each value has its own cell.
Applying this logic to population genetic data means that each individual should
have its own row, with individual metadata (such as its population, sex, phenotype, etc)
as the variables. Genotypes for each locus can also be thought as variables, however, due
to the large number of loci and the restricted values that each genotype can take, it would
be very inefficient to store them as individual standard columns. 

In `tidypopgen`, we represent data as a `gen_tbl`, a subclass of `tibble` which has
four compulsory columns: `id` of the individual (as a `character`, which must 
be unique for each individual), `population` giving the population the 
individuals belong to (a `factor`), `ploidy` giving the ploidy of the individual, and `genotypes` (
using `SNPBin` to provide a compressed representation of all the genotypes, which
can be decompressed as needed). In order to define the loci stored in the `SNPBin` objects,
we also require an additional tibble stored as the attribute `loci` to the main `gen_tbl`. 
The `loci` tibble includes columns
`name` for the locus name (a `character`, which must be unique), `chromosome` for the chromosome (`a factor`, if known, 
otherwise set to `NA`), `position` for the position on the chromosome (`numeric`, if known, 
otherwise set to `NA`), `allele_ref` for the the reference allele (a character),
and `allele_alt` for the alternate allele (a character, which can be `NA` for
monomorphic loci). Additional individual metadata can be stored as columns in
the main `gen_tbl`, whilst additional loci information (such as the position in 
centimorgans) can be added as columns in the `loci` attribute table.

# The grammar of population genetics

We can create a simple `gen_tbl` object with
```{r}
test_gen <- gen_tibble(indiv_metadata, genotypes, loci)
```

where `indiv_metadata` is a tibble of individual metadata, `genotypes` is a matrix of counts of alternate
allele, and `loci` is a tibble of loci metadata.

The individual metadata can then be processed with the usual `tidiverse` grammar.
So, we can filter individuals by population with
```{r}
test_pop1 <- test_gen %>% filter (pop=="pop1")
```

There are a number of functions that compute population genetics quantities for each
individual, such as heterozygosity. We can compute them simply with:
```{r}
test_gen %>% heterozygosity()
```

We will often want to group the table by population to create summary statistics.
For example, for computing pairwise Fst, we will
```{r}
test_gen %>% group_by(pop) %>% pairwise_fst()
```

We can easily add additional variables and group by those (e.g. continent, or
cluster membership)

For operations that focus on the loci, `tidypopgen` provides a grammar analogous
to the main `tidyverse`. For example, to select loci with a MAF >0.05, we simply
say:
```{r}
test_maf <- test_gen %>% select_loci(maf()>0.05)
```

To remove loci which are monomorphic in our dataset, we can simply say:
```{r}
test_maf <- test_gen %>% select_loci(!monomorphic())
```

Note that, since loci are notionally columns in our table, we use `select` rather
than `filter`

We can flip the strand of a subset with alleles with
```{r}
test_gen <- test_gen %>% flip_strands(c("rs134343","rs343533"))
```

Or swap the reference and alternate allele with:
```{r}
test_gen <- test_gen %>% swap_ref(c("rs134343","rs343533"))
```

For the above, we might want to use a verb `mutate_loci`, which then takes the 
function. But maybe that's just overly complicated (on the other hand, it would
clarify that the operation is about to change the loci, which is a big deal).
