#' Run SNMF from R in tidypopgen
#'
#' @details This is a wrapper for the function snmf from R package LEA.
#'
#' @param x a `gen_tibble` or a character giving the path to the input geno file
#' @param k an integer giving the number of clusters
#' @param project one of "continue", "new", and "force": "continue" stores files in the current
#' project, "new" creates a new project, and "force" stores results in the current project even
#' if the .geno input file has been altered,
#' @param n_runs the number of runs for each k value (defaults to 1)
#' @param alpha numeric snmf regularization parameter. See LEA::snmf for details
#' @param tolerance numeric value of tolerate error
#' @param entropy boolean indicating whether to estimate cross-entropy
#' @param percentage numeric value indicating percentage of masked genotypes,
#' ranging between 0 and 1, to be used when entropy = TRUE
#' @param I number of SNPs for initialising the snmf algorithm
#' @param iterations numeric integer for maximum iterations
#' @param ploidy the ploidy of the input data (defaults to 2)
#' @param seed the seed for the random number generator
#' @return an object of class `gt_admix` consisting of a list with the following elements:
#' - `k` the number of clusters
#' - `Q` a matrix with the admixture proportions
#' - `P` a matrix with the allele frequencies
#' - `log` a log of the output generated by ADMIXTURE (usually printed on the screen when running from the command line)
#' - `cv` the cross validation error (if `crossval` is TRUE)
#' - `loglik` the log likelihood of the model
#' - `id` the id column of the input `gen_tibble` (if applicable)
#' - `group` the group column of the input `gen_tibble` (if applicable)
#' @export

gt_snmf <- function (x, k, project = "continue", n_runs = 1, alpha, tolerance, entropy = TRUE,
                     percentage = NULL, I, iterations, ploidy = 2, seed = NULL){

  # add seed check again!!!
  if (length(seed)!= n_runs){
    stop("'seed' should be a vector of length 'n_runs'")
  }

  # if entropy = TRUE check percentage is given
  if (entropy & is.null(percentage)) {
    stop("If entropy is TRUE, percentage must be given")
  }

  # if required install LEA
  if (!requireNamespace("LEA", quietly = TRUE)) {
    install.packages("LEA")
  }

  if(inherits(x, "gen_tbl")){
    input_file <- gt_as_geno_lea(x)
    # expand path to file to be full path
    input_file <- normalizePath(input_file)
    out_file <- sub(".geno","", input_file)
    file_name <- sub(".geno","", basename(input_file))
  } else if(inherits(x, "character")){
    if (!file.exists(x)) {
      stop("The file ", x, " does not exist")
    }
    # check whether the file ends in .geno
    if (!grepl(".geno$", x)) {
      stop("The input file must be a .geno file")
    }
    input_file <- x
    out_file <- sub(".geno","", input_file)
    file_name <- sub(".geno","", basename(input_file))
  } else if(!inherits(x, "character")){
    stop("x must be a gen_tibble or a character giving the path to the input geno file")
  }

  # cast k as an integer
  k <- as.integer(k)

  # initialise list to store results
  adm_list <- list(
    k = integer(),
    Q = list(),
    P = list(),
    log = list(),
    loglik = numeric()
  )
  class(adm_list) <- c("gt_admix","list")

  # if seed is not given
  if (is.null(seed)) {
    snmf_res <- utils::capture.output(LEA::snmf(input.file = input_file,
                          K = k,
                          project = project, #
                          repetitions = n_runs,
                          alpha = alpha, #
                          tolerance = tolerance, #
                          entropy = entropy,
                          percentage = percentage, #
                          I = I, #
                          iterations = iterations, #
                          ploidy = ploidy))
  } else {
    snmf_res <- utils::capture.output(LEA::snmf(input.file = input_file,
                          K = k,
                          project = project, #
                          repetitions = n_runs,
                          alpha = alpha, #
                          tolerance = tolerance, #
                          entropy = entropy,
                          percentage = percentage, #
                          I = I, #
                          iterations = iterations, #
                          ploidy = ploidy, #
                          seed = seed))
  }

  # loop over values of k and number of repeats
  index <- 1
  for (this_k in as.integer(k)) {
    for (this_rep in seq_len(n_runs)) {

      adm_list$k[index] <- this_k
      adm_list$Q[[index]] <- q_matrix(utils::read.table(paste0(out_file,".snmf/K",this_k,
                                                               "/run",this_rep,"/",file_name,
                                                               "_r",this_rep,".",this_k,".Q"), header = FALSE))
      index <- index + 1
    }
  }

  # add log
  adm_list$log <- snmf_res

  # add metadata if x is a gen_tibble
  if (inherits(x, "gen_tbl")) {
    adm_list$id <- x$id
    # if it is grouped, add the group
    if (inherits(x, "grouped_gen_tbl")) {
      adm_list$group <- x[[dplyr::group_vars(x)]]
    }
  }

  # add info on algorithm
  adm_list$algorithm <- "SNMF"

  return(adm_list)
}
