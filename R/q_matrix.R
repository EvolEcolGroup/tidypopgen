#' Read and structure .Q files or existing matrices as 'q_matrix' objects.
#'
#' This function reads .Q matrix files generated by external clustering
#' algorithms (such as ADMIXTURE) and transforms them into 'q_matrix' objects
#' for plotting.
#'
#' @param x can be:
#' - a path to a directory containing .Q files
#' - a path to a single .Q file
#' - a matrix
#' - a dataframe
#' @returns either:
#' - a single `q_matrix` object
#' - a list of `q_matrix` objects
#' - a `q_matrix_list` object (for directories containing multiple runs) of q_matrix objects
#' @export
q_matrix <- function(x) {

  if (inherits(x, "data.frame") || inherits(x, "matrix")) {
    x <- as_q_matrix(x)
    return(x)

  } else if (!dir.exists(x) && !file.exists(x)){
    stop("Input is not a valid dataframe, file or directory")

  } else if (!dir.exists(x) && file.exists(x)){
      if ((grepl("\\.Q$", x)) == FALSE){
        #if input file does not end in Q
        stop("Input file does not end in '.Q'")
      }
    # Action if input is a file
    if (grepl("\\.Q$", x) == TRUE) {
      x <- utils::read.table(x, header = FALSE)
      x <- as_q_matrix(x)
      return(x)
    }
  } else if (dir.exists(x)) {
    # List all .Q files in the directory
    files <- list.files(x, pattern = "\\.Q$", full.names = TRUE)

    # Check if the directory contains at least one .Q file
    if (length(files) == 0) {
      stop("No .Q files found in the directory")
    }
    # Read all .Q files into a list
    data_list <- lapply(files, function(file) utils::read.table(file, header = FALSE))
    # Turn each data frame into a Q matrix
    matrix_list <- lapply(data_list, FUN = as_q_matrix)
    # Get the number of columns for each Q matrix (which corresponds to K)
    k_values <- sapply(matrix_list, ncol)
    # Create a list of lists, grouping matrices by their number of columns (K)
    list_of_lists <- split(matrix_list, k_values)
    # Rename the list so that each K is prefixed with "k"
    names(list_of_lists) <- paste0("k", names(list_of_lists))
    # Return the list of lists
    class(list_of_lists) <- c("q_matrix_list", class(list_of_lists))
    return(list_of_lists)

  }
}

#' Tidy a Q matrix
#'
#' Takes a `q_matrix` object, which is a matrix, and returns a tidied tibble.
#'
#' @param x A Q matrix object (as returned by LEA::Q()).
#' @param data An associated tibble (e.g. a [`gen_tibble`]), with the individuals in the same order as the data used to
#' generate the Q matrix
#' @param ... not currently used
#' @return A tidied tibble
#' @export
tidy.q_matrix <- function(x, data, ...){
  rlang::check_dots_empty()

  if(inherits(data,"grouped_df")){
    q_tbl <- x %>%
      tibble::as_tibble()

    groupdf <- data %>% dplyr::group_data()
    colu <- seq(1,nrow(data))

    for (i in seq_len(nrow(groupdf))) {
      group_rows <- groupdf$.rows[[i]]
      group_name <- groupdf[[1]][i]
      colu[group_rows] <- group_name
    }

    q_tbl <- q_tbl  %>%
      dplyr::mutate(id = data$id,
                    group = colu)
  } else if ("population" %in% names(data)){
    q_tbl <- x %>%
      tibble::as_tibble() %>%
      dplyr::mutate(id = data$id,
                    group = data$population)
  } else {
    q_tbl <- x %>%
      tibble::as_tibble() %>%
      dplyr::mutate(id = data$id)
  }
  q_tbl
}


#' Augment data with information from a q_matrix object
#'
#' Augment for `q_matrix` accepts a model object and a dataset and adds
#' Q values to each observation in the dataset.
#' Q values  are stored in separate columns, which is given name with the
#' pattern ".Q1",".Q2", etc. For consistency with [broom::augment.prcomp], a column
#' ".rownames" is also returned; it is a copy of 'id', but it ensures that
#' any scripts written for data augmented with [broom::augment.prcomp] will
#' work out of the box (this is especially helpful when adapting plotting scripts).
#' @param x  A `q_matrix` object
#' @param data the `gen_tibble` used to run the clustering algorithm
#' @param ... Not used. Needed to match generic signature only.
#' @return A  [gen_tibble] containing the original data along with
#'   additional columns containing each observation's Q values.
#' @export
#' @name augment_q_matrix

augment.q_matrix <- function(x, data = NULL, ...) {

  if(inherits(data,"grouped_df")){

    if (!".rownames" %in% names(data)) {
      group_vars <- group_vars(data)
      data <- data %>% dplyr::ungroup()
      data <- data %>%
        dplyr::mutate(.rownames = row_number())
      data <- data %>% dplyr::group_by(across(all_of(group_vars)))
    }
  } else {
    if (!".rownames" %in% names(data)) {
      data <- data %>%
        dplyr::mutate(.rownames = data$id)
    }
  }

  q_tbl <- tidy(x,data)

  if ("population" %in% names(data)) {
    if(all(data$population == q_tbl$group)){
      q_tbl <- q_tbl %>% dplyr::select(-.data$group)
    }
  }

  data <- dplyr::left_join(data,q_tbl, by = "id")
}


#' Autoplots for `q_matrix` objects
#'
#' @param object A Q matrix object (as returned by [q_matrix()]).
#' @param data An associated tibble (e.g. a [`gen_tibble`]), with the individuals in the same order as the data used to
#' generate the Q matrix
#' @param annotate_group Boolean determining whether to annotate the plot with the
#' group information
#' @param ... not currently used.
#' @returns a barplot of individuals, coloured by ancestry proportion
#'
#' @export

autoplot.q_matrix <- function(object, data = NULL, annotate_group = TRUE, ...){

  rlang::check_dots_empty()
  K <- ncol(object)
  if (is.null(data)) {
    q_tbl <- as.data.frame(object)
    q_tbl$id <- 1:nrow(q_tbl)
    q_tbl <- q_tbl %>% tidyr::pivot_longer(cols = dplyr::starts_with(".Q"),
                                       names_to = "q", values_to = "percentage")
    plt <- ggplot2::ggplot(q_tbl,
                           ggplot2::aes(x = .data$id,
                                        y = .data$percentage,
                                        fill = .data$q)) +
      ggplot2::geom_col(width = 1,
                        position = ggplot2::position_stack(reverse = TRUE))+
      ggplot2::labs(y = paste("K = ", K))+
      theme_distruct() +
      scale_fill_distruct()

    plt

    # thin vertical lines show when plot is saved as .pdf and opened with certain viewers,
    # this is a product of the specific viewer (seen on unix and mac), knitting to
    # html instead fixes, or choosing a different output (not pdf)

  } else {
    q_tbl <- tidy(object, data)

    q_tbl <- q_tbl %>% tidyr::pivot_longer(cols = dplyr::starts_with(".Q"),
                                           names_to = "q", values_to = "percentage") %>%
      dplyr::mutate(percentage = as.numeric(.data$percentage))

    q_tbl <- q_tbl %>%
      dplyr::group_by(.data$group, .data$id) %>%
      dplyr::arrange(.data$group, .data$id) %>%
      dplyr::mutate(q = factor(.data$q, levels = .data$q[order(.data$percentage, decreasing = FALSE)]))

    dominant_q <- q_tbl %>%
      dplyr::group_by(.data$id) %>%
      dplyr::summarize(dominant_q = max(.data$percentage), .groups = 'drop')

    q_tbl <- q_tbl %>%
      dplyr::left_join(dominant_q, by = "id")

    q_tbl <- q_tbl %>%
      dplyr::group_by(.data$group) %>%
      dplyr::arrange(desc(.data$dominant_q), .by_group = TRUE)

    levels_q <- unique(q_tbl$id)

    q_tbl <- q_tbl %>%
      dplyr::mutate(id = factor(.data$id, levels = levels_q))

    plt <- ggplot2::ggplot(q_tbl,
                           ggplot2::aes(x = .data$id,
                                        y = .data$percentage,
                                        fill = .data$q)) +
      ggplot2::geom_col(width = 1,
                        position = "stack")+
      ggplot2::labs(y = paste("K = ", K))+
      theme_distruct() +
      scale_fill_distruct()

    if (annotate_group){
      if (is.null(data)){
        warning("no annotation possible if 'gen_tbl' is NULL")
      } else {
        plt <- plt + annotate_group_info(q_tbl)
      }
    }
    plt
  }

}

#' Summarise a Q matrix list
#'
#' Takes a `q_matrix_list` object and returns a summary.
#'
#' @param object A `q_matrix_list` object.
#' @param ... not currently used
#' @return A summary of the object.
#' @export
summary.q_matrix_list <- function(object, ...) {
  k_values <- names(object)

  summary_df <- data.frame(K = integer(), Repeats = integer())

  for (k in k_values) {
    k_numeric <- as.numeric(sub("k", "", k))

    num_repeats <- length(object[[k]])

    summary_df <- rbind(summary_df, data.frame(K = k_numeric, Repeats = num_repeats))
  }
  return(summary_df)
}


as_q_matrix <- function(x){
  if (inherits(x,"data.frame")){
    x <- as.matrix(x)
  }
  colnames(x)<- paste0(".Q",seq_len(ncol(x)))
  class(x) <- c("q_matrix",class(x))
  x
}







