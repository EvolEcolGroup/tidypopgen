#' Read and structure .Q files or existing matrices as 'q_matrix' objects.
#'
#' This function reads .Q matrix files generated by external clustering
#' algorithms (such as ADMIXTURE) and transforms them into 'q_matrix' objects
#' for plotting.
#'
#' @param x can be:
#' - a path to a directory containing .Q files
#' - a path to a single .Q file
#' - a matrix
#' - a dataframe
#' - a list of dataframes or matrices
#' @returns either:
#' - a single `q_matrix` object
#' - a `q_matrix_list` object containing a list of Q matrices and a list of indices for each Q matrix separated by K
#' @export
#' @aliases q_matrix_list

q_matrix <- function(x) {
  # Sub function to process q-matrix and create output list
  process_q_matrix <- function(matrix_list) {
    # Get the number of columns for each Q matrix (which corresponds to K)
    k_values <- sapply(matrix_list, ncol)
    # Create a list of lists, grouping matrix indices by k
    k_list_of_lists <- split(seq_along(matrix_list), k_values)
    # Rename the list so that each K is prefixed with "k"
    names(k_list_of_lists) <- paste0("k", names(k_list_of_lists))
    # Create main list containing k_list and matrix list
    q_matrix_list <- list(k_indices = k_list_of_lists, q_matrices = matrix_list)
    # Set class and return the final list
    class(q_matrix_list) <- c("q_matrix_list", class(q_matrix_list))
    return(q_matrix_list)
  }

  # Check if input is a single data frame or matrix
  if (inherits(x, "data.frame") || inherits(x, "matrix")) {
      x <- as_q_matrix(x)
      return(x)

    # Check if input is a flat list of q-matrices
  } else if (is.list(x) && all(sapply(x, function(element) inherits(element, c("data.frame", "matrix"))))) {
    # Convert each element to a q-matrix
    matrix_list <- lapply(x, as_q_matrix)
    return(process_q_matrix(matrix_list))

    # Check if input is an invalid path
  } else if (!dir.exists(x) && !file.exists(x)){
    stop("Input is not a valid dataframe, file, directory, or list of q-matrices")

    # Check if input is a single file path
  } else if (!dir.exists(x) && file.exists(x)) {
    if (!grepl("\\.Q$", x)) {
      stop("Input file does not end in '.Q'")
    }
    # Read file, convert to q-matrix, and process
      x <- utils::read.table(x, header = FALSE)
      x <- as_q_matrix(x)
      return(x)

    # Check if input is a directory of q-files
  } else if (dir.exists(x)) {
    # List all .Q files in the directory
    files <- list.files(x, pattern = "\\.Q$", full.names = TRUE)

    # Check if the directory contains at least one .Q file
    if (length(files) == 0) {
      stop("No .Q files found in the directory")
    }

    # Read all .Q files into a list and convert each to a q-matrix
    matrix_list <- lapply(files, function(file) as_q_matrix(utils::read.table(file, header = FALSE)))
    return(process_q_matrix(matrix_list))
  }
}

#' Return a single Q matrix from a `q_matrix_list` object
#'
#' This function retrieves a single Q matrix from a `q_matrix_list` object
#' based on the specified k value and run number.
#'
#' @param x A `q_matrix_list` object containing multiple Q matrices
#' @param ... Not used
#' @param k The k value of the desired Q matrix
#' @param run The run number of the desired Q matrix
#' @return A single Q matrix from the `q_matrix_list` object
#' @export

get_q <- function(x, ..., k, run) {
  # Check if 'x' is a valid q_matrix_list object
  if (!inherits(x, "q_matrix_list")) {
    stop("Input must be a 'q_matrix_list' object")
  }

  # Check if the requested k exists in k_indices
  k_name <- paste0("k", k)
  if (!k_name %in% names(x$k_indices)) {
    stop("Specified k value not found in q_matrix_list")
  }

  # Get the indices for the specified k
  k_indices <- x$k_indices[[k_name]]

  # Check if the specified run is valid within the chosen k
  if (run < 1 || run > length(k_indices)) {
    stop("Specified run is out of range for the given k value")
  }

  # Get the index of the desired q-matrix in q_matrices
  matrix_index <- k_indices[run]

  # Retrieve and return the q-matrix
  q_matrix <- x$q_matrices[[matrix_index]]
  return(q_matrix)
}

#' Return a single P matrix from a `q_matrix_list` object
#'
#' This function retrieves a single P matrix from a `q_matrix_list` object
#' based on the specified k value and run number.
#'
#' @param x A `q_matrix_list` object containing P matrices
#' @param ... Not used
#' @param k The k value of the desired P matrix
#' @param run The run number of the desired P matrix
#' @return A single P matrix from the `q_matrix_list` object
#' @export

get_p <- function(x, ..., k, run) {
  # Check if 'x' is a valid q_matrix_list object
  if (!inherits(x, "q_matrix_list")) {
    stop("Input must be a 'q_matrix_list' object")
  }

  # Check if p_matrices exists in x
  if (!"p_matrices" %in% names(x)) {
    stop("Input object does not contain any P matrices")
  }

  # Check if the requested k exists in k_indices
  k_name <- paste0("k", k)
  if (!k_name %in% names(x$k_indices)) {
    stop("Specified k value not found in q_matrix_list")
  }

  # Get the indices for the specified k
  k_indices <- x$k_indices[[k_name]]

  # Check if the specified run is valid within the chosen k
  if (run < 1 || run > length(k_indices)) {
    stop("Specified run is out of range for the given k value")
  }

  # Get the index of the desired p-matrix in p_matrices
  matrix_index <- k_indices[run]

  # Retrieve and return the p-matrix
  p_matrix <- x$p_matrices[[matrix_index]]
  return(p_matrix)
}

#' Tidy a Q matrix
#'
#' Takes a `q_matrix` object, which is a matrix, and returns a tidied tibble.
#'
#' @param x A Q matrix object (as returned by [`q_matrix`]).
#' @param data An associated tibble (e.g. a [`gen_tibble`]), with the individuals in the same order as the data used to
#' generate the Q matrix
#' @param ... not currently used
#' @return A tidied tibble
#' @export
tidy.q_matrix <- function(x, data, ...){
  rlang::check_dots_empty()

  if(inherits(data,"grouped_df")){
    q_tbl <- x %>%
      tibble::as_tibble()

    groupdf <- data %>% dplyr::group_data()
    colu <- seq(1,nrow(data))

    for (i in seq_len(nrow(groupdf))) {
      group_rows <- groupdf$.rows[[i]]
      group_name <- groupdf[[1]][i]
      colu[group_rows] <- group_name
    }

    q_tbl <- q_tbl  %>%
      dplyr::mutate(id = data$id,
                    group = colu)
  } else if ("population" %in% names(data)){
    q_tbl <- x %>%
      tibble::as_tibble() %>%
      dplyr::mutate(id = data$id,
                    group = data$population)
  } else {
    q_tbl <- x %>%
      tibble::as_tibble() %>%
      dplyr::mutate(id = data$id)
  }
  q_tbl
}


#' Augment data with information from a q_matrix object
#'
#' Augment for `q_matrix` accepts a model object and a dataset and adds
#' Q values to each observation in the dataset.
#' Q values  are stored in separate columns, which is given name with the
#' pattern ".Q1",".Q2", etc. For consistency with [broom::augment.prcomp], a column
#' ".rownames" is also returned; it is a copy of 'id', but it ensures that
#' any scripts written for data augmented with [broom::augment.prcomp] will
#' work out of the box (this is especially helpful when adapting plotting scripts).
#' @param x  A `q_matrix` object
#' @param data the `gen_tibble` used to run the clustering algorithm
#' @param ... Not used. Needed to match generic signature only.
#' @return A  [gen_tibble] containing the original data along with
#'   additional columns containing each observation's Q values.
#' @export
#' @name augment_q_matrix

augment.q_matrix <- function(x, data = NULL, ...) {

  if(inherits(data,"grouped_df")){

    if (!".rownames" %in% names(data)) {
      group_vars <- group_vars(data)
      data <- data %>% dplyr::ungroup()
      data <- data %>%
        dplyr::mutate(.rownames = row_number())
      data <- data %>% dplyr::group_by(across(all_of(group_vars)))
    }
  } else {
    if (!".rownames" %in% names(data)) {
      data <- data %>%
        dplyr::mutate(.rownames = data$id)
    }
  }

  q_tbl <- tidy(x,data)

  if ("population" %in% names(data)) {
    if(all(data$population == q_tbl$group)){
      q_tbl <- q_tbl %>% dplyr::select(-.data$group)
    }
  }

  data <- dplyr::left_join(data,q_tbl, by = "id")
}


#' Autoplots for `q_matrix` objects
#'
#' @param object A Q matrix object (as returned by [q_matrix()]).
#' @param data An associated tibble (e.g. a [`gen_tibble`]), with the individuals in the same order as the data used to
#' generate the Q matrix
#' @param annotate_group Boolean determining whether to annotate the plot with the
#' group information
#' @param ... not currently used.
#' @returns a barplot of individuals, coloured by ancestry proportion
#'
#' @export

autoplot.q_matrix <- function(object, data = NULL, annotate_group = TRUE, ...){

  rlang::check_dots_empty()
  K <- ncol(object)
  if (is.null(data)) {
    q_tbl <- as.data.frame(object)
    q_tbl$id <- 1:nrow(q_tbl)
    q_tbl <- q_tbl %>% tidyr::pivot_longer(cols = dplyr::starts_with(".Q"),
                                       names_to = "q", values_to = "percentage")
    plt <- ggplot2::ggplot(q_tbl,
                           ggplot2::aes(x = .data$id,
                                        y = .data$percentage,
                                        fill = .data$q)) +
      ggplot2::geom_col(width = 1,
                        position = ggplot2::position_stack(reverse = TRUE))+
      ggplot2::labs(y = paste("K = ", K))+
      theme_distruct() +
      scale_fill_distruct()

    plt

    # thin vertical lines show when plot is saved as .pdf and opened with certain viewers,
    # this is a product of the specific viewer (seen on unix and mac), knitting to
    # html instead fixes, or choosing a different output (not pdf)

  } else {
    q_tbl <- tidy(object, data)

    q_tbl <- q_tbl %>% tidyr::pivot_longer(cols = dplyr::starts_with(".Q"),
                                           names_to = "q", values_to = "percentage") %>%
      dplyr::mutate(percentage = as.numeric(.data$percentage))

    q_tbl <- q_tbl %>%
      dplyr::group_by(.data$group, .data$id) %>%
      dplyr::arrange(.data$group, .data$id) %>%
      dplyr::mutate(q = factor(.data$q, levels = .data$q[order(.data$percentage, decreasing = FALSE)]))

    dominant_q <- q_tbl %>%
      dplyr::group_by(.data$id) %>%
      dplyr::summarize(dominant_q = max(.data$percentage), .groups = 'drop')

    q_tbl <- q_tbl %>%
      dplyr::left_join(dominant_q, by = "id")

    q_tbl <- q_tbl %>%
      dplyr::group_by(.data$group) %>%
      dplyr::arrange(desc(.data$dominant_q), .by_group = TRUE)

    levels_q <- unique(q_tbl$id)

    q_tbl <- q_tbl %>%
      dplyr::mutate(id = factor(.data$id, levels = levels_q))

    plt <- ggplot2::ggplot(q_tbl,
                           ggplot2::aes(x = .data$id,
                                        y = .data$percentage,
                                        fill = .data$q)) +
      ggplot2::geom_col(width = 1,
                        position = "stack")+
      ggplot2::labs(y = paste("K = ", K))+
      theme_distruct() +
      scale_fill_distruct()

    if (annotate_group){
      if (is.null(data)){
        warning("no annotation possible if 'gen_tbl' is NULL")
      } else {
        plt <- plt + annotate_group_info(q_tbl)
      }
    }
    plt
  }

}

#' Summarise a Q matrix list
#'
#' Takes a `q_matrix_list` object and returns a summary.
#'
#' @param object A `q_matrix_list` object.
#' @param ... not currently used
#' @return A summary of the object.
#' @export
summary.q_matrix_list <- function(object, ...) {
  # Check if 'x' is a valid q_matrix_list object
  if (!inherits(object, "q_matrix_list")) {
    stop("Input must be a 'q_matrix_list' object")
  }
  k_values <- names(object$k_indices)
  summary_df <- data.frame(K = integer(), Repeats = integer())
  for (k in k_values) {
    k_numeric <- as.numeric(sub("k", "", k))
    num_repeats <- length(object$k_indices[[k]])
    summary_df <- rbind(summary_df, data.frame(K = k_numeric, Repeats = num_repeats))
  }
  return(summary_df)
}

# Convert a matrix to a q_matrix object
as_q_matrix <- function(x){
  if (inherits(x,"data.frame")){
    x <- as.matrix(x)
  }
  colnames(x)<- paste0(".Q",seq_len(ncol(x)))
  class(x) <- c("q_matrix",class(x))
  x
}

