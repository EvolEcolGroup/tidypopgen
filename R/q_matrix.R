#' Read and structure .Q files or existing matrices as `q_matrix` or `gt_admix` objects.
#'
#' This function reads .Q matrix files generated by external clustering
#' algorithms (such as ADMIXTURE) and transforms them into `gt_admix` objects.
#'
#' @param x can be:
#' - a path to a directory containing .Q files
#' @return
#' - a `gt_admix` object containing a list of Q matrices and a list of
#' indices for each Q matrix separated by K
#' @export
read_q_files <- function(x) {

  if (!dir.exists(x)){
    stop("Input is not a valid directory")
  } else if (dir.exists(x)) {
    # List all .Q files in the directory
    files <- list.files(x, pattern = "\\.Q$", full.names = TRUE)

    # Check if the directory contains at least one .Q file
    if (length(files) == 0) {
      stop("No .Q files found in the directory")
    }

    # Read all .Q files into a list and convert each to a q-matrix
    matrix_list <- lapply(files, function(file) q_matrix(utils::read.table(file, header = FALSE)))

    # Get the number of columns for each Q matrix (which corresponds to K)
    k_values <- sapply(matrix_list, ncol)
    # Create main list containing k_list and matrix list
    gt_admix <- list(k = k_values, Q = matrix_list)
    # Set class and return the final list
    class(gt_admix) <- c("gt_admix", class(gt_admix))
    return(gt_admix)
  }
}

#' Convert a standard matrix to a `q_matrix` object
#'
#' Takes a single Q matrix that exists as either a matrix or a data frame and
#' returns a `q_matrix` object.
#'
#' @param x A matrix or a data frame
#' @return A `q_matrix` object
#' @export
q_matrix <- function(x){
  if (inherits(x,"data.frame")){
    x <- as.matrix(x)
  }
  colnames(x)<- paste0(".Q",seq_len(ncol(x)))
  class(x) <- c("q_matrix",class(x))
  return(x)
}


#' Return a single Q matrix from a `gt_admix` object
#'
#' This function retrieves a single Q matrix from a `gt_admix` object
#' based on the specified k value and run number.
#'
#' @param x A `gt_admix` object containing multiple Q matrices
#' @param ... Not used
#' @param k The k value of the desired Q matrix
#' @param run The run number of the desired Q matrix
#' @return A single Q matrix from the `gt_admix` object
#' @export
get_q_matrix <- function(x, ..., k, run) {
  # Check if 'x' is a valid gt_admix object
  if (!inherits(x, "gt_admix")) {
    stop("Input must be a 'gt_admix' object")
  }

  # Check if the requested k exists in k_indices
  if (!k %in% x$k) {
    stop("Specified k value not found in gt_admix")
  }

  k_values <- split(seq_along(x$k), x$k)

  k <- which(names(k_values)==k)

  # Get the indices for the specified k
  k_indices <- k_values[[k]]

  # Check if the specified run is valid within the chosen k
  if (run < 1 || run > length(k_indices)) {
    stop("Specified run is out of range for the given k value")
  }

  # Get the index of the desired q-matrix in q_matrices
  matrix_index <- k_indices[run]

  # Retrieve and return the q-matrix
  q_matrix <- x$Q[[matrix_index]]
  # if the id variable exists, add it as an attribute
  if ("id" %in% names(x)){
    attr(q_matrix, "id") <- x$id
  }
  # if a grouping varible exist, add it as an attribute
  if ("group" %in% names(x)){
    attr(q_matrix, "group") <- x$group
  }
  class(q_matrix) <- c("q_matrix",class(q_matrix))
  return(q_matrix)
}

#' Return a single P matrix from a `gt_admix` object
#'
#' This function retrieves a single P matrix from a `gt_admix` object
#' based on the specified k value and run number.
#'
#' @param x A `gt_admix` object containing P matrices
#' @param ... Not used
#' @param k The k value of the desired P matrix
#' @param run The run number of the desired P matrix
#' @return A single P matrix from the `gt_admix` object
#' @export
get_p_matrix <- function(x, ..., k, run) {
  # Check if 'x' is a valid gt_admix object
  if (!inherits(x, "gt_admix")) {
    stop("Input must be a 'gt_admix' object")
  }

  # Check if p_matrices exists in x
  if (!"P" %in% names(x)) {
    stop("Input object does not contain any P matrices")
  }

  # Check if the requested k exists in k_indices
  if (!k %in% x$k) {
    stop("Specified k value not found in gt_admix")
  }

  k_values <- split(seq_along(x$k), x$k)

  k <- which(names(k_values)==k)

  # Get the indices for the specified k
  k_indices <- k_values[[k]]

  # Check if the specified run is valid within the chosen k
  if (run < 1 || run > length(k_indices)) {
    stop("Specified run is out of range for the given k value")
  }

  # Get the index of the desired p-matrix in p_matrices
  matrix_index <- k_indices[run]

  # Retrieve and return the p-matrix
  p_matrix <- x$P[[matrix_index]]
  return(p_matrix)
}


#' Tidy a Q matrix
#'
#' Takes a `q_matrix` object, which is a matrix, and returns a tidied tibble.
#'
#' @param x A Q matrix object (as returned by [`q_matrix`]).
#' @param data An associated tibble (e.g. a [`gen_tibble`]), with the individuals in the same order as the data used to
#' generate the Q matrix
#' @param ... not currently used
#' @return A tidied tibble
#' @export
tidy.q_matrix <- function(x, data, ...){
  rlang::check_dots_empty()

  if(inherits(data,"grouped_df")){
    q_tbl <- x %>%
      tibble::as_tibble()

    groupdf <- data %>% dplyr::group_data()
    colu <- seq(1,nrow(data))

    for (i in seq_len(nrow(groupdf))) {
      group_rows <- groupdf$.rows[[i]]
      group_name <- groupdf[[1]][i]
      colu[group_rows] <- group_name
    }

    q_tbl <- q_tbl  %>%
      dplyr::mutate(id = data$id,
                    group = colu)
  # } else if ("population" %in% names(data)){
  #   q_tbl <- x %>%
  #     tibble::as_tibble() %>%
  #     dplyr::mutate(id = data$id,
  #                   group = data$population)
  } else {
    q_tbl <- x %>%
      tibble::as_tibble() %>%
      dplyr::mutate(id = data$id)
  }
  q_tbl
}


#' Augment data with information from a q_matrix object
#'
#' Augment for `q_matrix` accepts a model object and a dataset and adds
#' Q values to each observation in the dataset.
#' Q values  are stored in separate columns, which is given name with the
#' pattern ".Q1",".Q2", etc. For consistency with [broom::augment.prcomp], a column
#' ".rownames" is also returned; it is a copy of 'id', but it ensures that
#' any scripts written for data augmented with [broom::augment.prcomp] will
#' work out of the box (this is especially helpful when adapting plotting scripts).
#' @param x  A `q_matrix` object
#' @param data the `gen_tibble` used to run the clustering algorithm
#' @param ... Not used. Needed to match generic signature only.
#' @return A  [gen_tibble] containing the original data along with
#'   additional columns containing each observation's Q values.
#' @export
#' @name augment_q_matrix
augment.q_matrix <- function(x, data = NULL, ...) {

  if(inherits(data,"grouped_df")){

    if (!".rownames" %in% names(data)) {
      group_vars <- group_vars(data)
      data <- data %>% dplyr::ungroup()
      data <- data %>%
        dplyr::mutate(.rownames = row_number())
      data <- data %>% dplyr::group_by(across(all_of(group_vars)))
    }
  } else {
    if (!".rownames" %in% names(data)) {
      data <- data %>%
        dplyr::mutate(.rownames = data$id)
    }
  }

  q_tbl <- tidy(x,data)

  # if ("population" %in% names(data)) {
  #   if(all(data$population == q_tbl$group)){
  #     q_tbl <- q_tbl %>% dplyr::select(-.data$group)
  #   }
  # }

  data <- dplyr::left_join(data,q_tbl, by = "id")
}


#' Autoplots for `q_matrix` objects
#'
#' @param object A Q matrix object (as returned by [q_matrix()]).
#' @param data An associated tibble (e.g. a [`gen_tibble`]), with the individuals in the same order as the data used to
#' generate the Q matrix
#' @param annotate_group Boolean determining whether to annotate the plot with the
#' group information
#' @param ... not currently used.
#' @returns a barplot of individuals, coloured by ancestry proportion
#'
#' @export
autoplot.q_matrix <- function(object, data = NULL, annotate_group = TRUE, ...){

  rlang::check_dots_empty()
  K <- ncol(object)
  # create dataset if we don't have a gen_tibble
  if (is.null(data)) {
    q_tbl <- as.data.frame(object)
    q_tbl$id <- 1:nrow(q_tbl)
    # if the q_matrix has a group attribute, add it to the data
    if ("group" %in% names(attributes(object))){
      q_tbl$group <- rep(attr(object, "group"), each=nrow(q_tbl)/length(attr(object, "group")))
    }
  } else { # if we have the info from the gen_tibble
    q_tbl <- tidy(object, data)
  }
    q_tbl <- q_tbl %>% tidyr::pivot_longer(cols = dplyr::starts_with(".Q"),
                                           names_to = "q", values_to = "percentage") %>%
      dplyr::mutate(percentage = as.numeric(.data$percentage))

    # resort data if we have a grouping variable and we plan to use it
    if (("group" %in% names(q_tbl))&&annotate_group){

    q_tbl <- q_tbl %>%
      dplyr::group_by(.data$group, .data$id) %>%
      dplyr::arrange(.data$group, .data$id) %>%
      dplyr::mutate(q = factor(.data$q, levels = .data$q[order(.data$percentage, decreasing = FALSE)]))

    dominant_q <- q_tbl %>%
      dplyr::group_by(.data$id) %>%
      dplyr::summarize(dominant_q = max(.data$percentage), .groups = 'drop')

    q_tbl <- q_tbl %>%
      dplyr::left_join(dominant_q, by = "id")

    q_tbl <- q_tbl %>%
      dplyr::group_by(.data$group) %>%
      dplyr::arrange(desc(.data$dominant_q), .by_group = TRUE)

    levels_q <- unique(q_tbl$id)

    q_tbl <- q_tbl %>%
      dplyr::mutate(id = factor(.data$id, levels = levels_q))
    }

    plt <- ggplot2::ggplot(q_tbl,
                           ggplot2::aes(x = .data$id,
                                        y = .data$percentage,
                                        fill = .data$q)) +
      ggplot2::geom_col(width = 1,
                        position = "stack")+
      ggplot2::labs(y = paste("K = ", K))+
      theme_distruct() +
      scale_fill_distruct()

    if (annotate_group){
      if (!"group" %in% names(q_tbl)) {
        warning("no annotation possible if 'gen_tbl' is NULL and q_matrix does not contain group information")
      } else {
        plt <- plt + annotate_group_info(q_tbl)
      }
    }
    plt

}
# thin vertical lines show when plot is saved as .pdf and opened with certain viewers,
# this is a product of the specific viewer (seen on unix and mac), knitting to
# html instead fixes, or choosing a different output (not pdf)

